<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>史继炜的个人博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-26T02:46:42.687Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SJW</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/11/30/docker%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/11/30/docker%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-29T17:01:09.004Z</published>
    <updated>2021-02-26T02:46:42.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Docker基本组成"><a href="#一、Docker基本组成" class="headerlink" title="一、Docker基本组成"></a>一、Docker基本组成</h1><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=793314303,480081697&fm=26&gp=0.jpg" alt="点击查看源网页"></p><p><strong>镜像（image）：</strong></p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，通过这个镜像可以创建多个容器（最终项目运行就是在容器中）。</p><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>容器基本命令=》启动、停止、删除</p><p><strong>仓库（repository）：</strong></p><p>仓库就是存放镜像的地方</p><p>仓库分为共有仓库和私有仓库</p><p>Docker Hub（默认是国外的仓库）</p><p>阿里云镜像加速器（配置镜像加速=》常用！！）</p><h1 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h1><h2 id="1、安装步骤"><a href="#1、安装步骤" class="headerlink" title="1、安装步骤"></a>1、安装步骤</h2><p><a href="https://docs.docker.com/engine/install/centos/">docker官方安装指南(centos)</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、卸载旧的docker版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、设置镜像的仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo #默认的是国外的！！</span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #常用阿里云的镜像仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、安装docker相关组件（默认最新版）</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 7、检查是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/22/ZTcXLIxRl4F5byD.png" alt="image-20210219092510818"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 8、运行hello world</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/24/1bTfaBgEuJn3iY8.png" alt="image-20210219092724962"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 9、查看docker镜像(mysql\redis是之前拉的镜像、按步骤现在只有hello-world的镜像)</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/24/tPdBLSVxsUbEyDn.png" alt="image-20210219093539353"></p><h2 id="2、回顾hello-world流程"><a href="#2、回顾hello-world流程" class="headerlink" title="2、回顾hello-world流程"></a>2、回顾hello-world流程</h2><p>上面步骤中运行了hello-word镜像，执行docker run之后发生了什么？</p><p><img src="https://i.loli.net/2021/02/22/Bpau912Hmc3SEFs.png" alt="image-20210219100047585"></p><h2 id="3、docker底层原理"><a href="#3、docker底层原理" class="headerlink" title="3、docker底层原理"></a>3、docker底层原理</h2><blockquote><p>docker是怎么工作的？</p></blockquote><p>docker是一个client-server结构的系统，docker的守护进程运行在主机上。通过socket从客服端访问！</p><p>dockerServer接收到Docker-Client的指令，就会执行这个命令！</p><p><img src="https://i.loli.net/2021/02/22/V1g3dE5uSD6bFWt.png" alt="image-20210219101422288"></p><blockquote><p>docker为什么比虚拟机快？</p></blockquote><p>1、docker有着比虚拟机更少的抽象层</p><p>2、docker利用的是宿主机的内核，vm需要的是guest OS</p><p><img src="https://i.loli.net/2021/02/24/NBrUb8WVMOeLYv5.png" alt="image-20210224182401352"></p><blockquote><p> 所有说，新建一个容器的时候，docker不需要像虚拟机一样加载一个操作系统内核，避免引导。虚拟机是加载guestOs，分钟级别的；而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p></blockquote><p><img src="https://i.loli.net/2021/02/22/WutS1CdoXcg9kiK.png" alt="image-20210219102708472"></p><h1 id="三、阿里云镜像加速"><a href="#三、阿里云镜像加速" class="headerlink" title="三、阿里云镜像加速"></a>三、阿里云镜像加速</h1><p>登陆阿里云：控制台=》产品与服务=》容器镜像服务=》镜像加速器</p><p>选择对应的操作系统</p><p><img src="https://i.loli.net/2021/02/22/TQy23u7VlzwmLRE.png" alt="image-20210219095101195"></p><p><img src="https://i.loli.net/2021/02/22/lY81sNFLfdhAP3U.png" alt="image-20210219095150647"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置命令：这里是centos，版本要对应</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://hfvn90en.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="四、Docker常用命令"><a href="#四、Docker常用命令" class="headerlink" title="四、Docker常用命令"></a>四、Docker常用命令</h1><h2 id="1、帮助命令"><a href="#1、帮助命令" class="headerlink" title="1、帮助命令"></a>1、帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version #显示docker版本信息</span><br><span class="line">docker info #显示docker的系统信息、包括镜像和容器的数量</span><br><span class="line">docker 命令 --help #帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档：<a href="https://docs.docker.com/reference/">官方文档</a></p><h2 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h2><h3 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h3><p>docker images</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">mysql         5.7       a70d36bc331a   4 weeks ago     449MB</span><br><span class="line">mysql         latest    c8562eaf9d81   4 weeks ago     546MB</span><br><span class="line">redis         latest    621ceef7494a   5 weeks ago     104MB</span><br><span class="line">hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收</span></span><br><span class="line">REPOSITORY 镜像的仓库源</span><br><span class="line">TAG   镜像的标签</span><br><span class="line">IMAGE ID   镜像的id</span><br><span class="line">CREATED   镜像创建的时间</span><br><span class="line">SIZE       镜像的大小</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">命令可选项</span></span><br><span class="line">-a, --all           #列出所有镜像</span><br><span class="line">-q, --quiet         #只显示镜像的id</span><br></pre></td></tr></table></figure><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>docker search</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10520     [OK]       </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3928      [OK]       </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项，进行过滤搜索</span></span><br><span class="line">--filter=stars=3000 #搜索出来的镜像就是stars大于3000的</span><br><span class="line">[root@SJW-aliyun ~]# docker search mysql --filter=stars=4000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   10520     [OK]     </span><br></pre></td></tr></table></figure><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>docker pull</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]==》  eg: docker pull tomcat:8.5</span></span><br><span class="line">[root@SJW-aliyun ~]# docker pull tomcat</span><br><span class="line">Using default tag: latest #如果不写tag，默认就是latest</span><br><span class="line">latest: Pulling from library/tomcat</span><br><span class="line">b9a857cbf04d: Pull complete #分层下载，docker images的核心 联合文件系统</span><br><span class="line">d557ee20540b: Pull complete #如果下载该镜像的其它版本可以共用相同的层，不需要重复下载，极大地节省空间</span><br><span class="line">3b9ca4f00c2e: Pull complete </span><br><span class="line">667fd949ed93: Pull complete </span><br><span class="line">661d3b55f657: Pull complete </span><br><span class="line">511ef4338a0b: Pull complete </span><br><span class="line">a56db448fefe: Pull complete </span><br><span class="line">00612a99c7dc: Pull complete </span><br><span class="line">326f9601c512: Pull complete </span><br><span class="line">c547db74f1e1: Pull complete </span><br><span class="line">Digest: sha256:94cc18203335e400dbafcd0633f33c53663b1c1012a13bcad58cced9cd9d1305</span><br><span class="line">Status: Downloaded newer image for tomcat:latest</span><br><span class="line">docker.io/library/tomcat:latest</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>docker rmi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker rmi a70d36bc331a #删除指定镜像</span><br><span class="line">[root@SJW-aliyun ~]# docker rmi 镜像id 镜像id #删除多个镜像</span><br><span class="line">[root@SJW-aliyun ~]# docker rmi $(docker images -aq) #删除多个镜像</span><br></pre></td></tr></table></figure><h2 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h2><blockquote><p>有了镜像才能 创建容器</p></blockquote><p>下载一个centos镜像来测试学习</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">7a0437f04f83: Pull complete </span><br><span class="line">Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure><h3 id="新建容器-并启动"><a href="#新建容器-并启动" class="headerlink" title="==新建容器==并启动"></a>==<strong>新建容器</strong>==并启动</h3><p>docker run</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">可选参数说明</span></span><br><span class="line">--name=&quot;name&quot;容器别名，用来区分容器</span><br><span class="line">-d后台方式交互</span><br><span class="line">-it使用交互方式运行，加入容器查看内容</span><br><span class="line">-p指定容器端口 -p 主机端口:容器端口</span><br><span class="line">-P随机指定端口</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试，启动并进入容器</span></span><br><span class="line">[root@SJW-aliyun ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@cd7a513e67b9 /]# ls#查看容器内的centos，其为基础版本，很多命令不完善</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"><span class="meta">#</span><span class="bash">从容器中退回主机</span></span><br><span class="line">[root@cd7a513e67b9 /]# exit</span><br><span class="line">exit</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h3><p>docker ps</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps 命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前正在运行的容器</span></span><br><span class="line">-a# 列出当前正在运行的容器+历史运行过的容器</span><br><span class="line">-n=？#显示最近创建的容器</span><br><span class="line">-q#只显示容器的编号</span><br><span class="line">[root@SJW-aliyun ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@SJW-aliyun ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                      PORTS     NAMES</span><br><span class="line">cd7a513e67b9   centos    &quot;/bin/bash&quot;              7 minutes ago   Exited (0) 5 minutes ago              hopeful_chaplygin</span><br><span class="line">e27753e62511   redis     &quot;docker-entrypoint.s…&quot;   11 days ago     Exited (0) 59 minutes ago             redis</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>docker rm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id#删除指定容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><br><span class="line">docker rm -f $(docker ps -a)#删除所有容器</span><br><span class="line">docker ps -a|xargs docker rm#删除所有容器</span><br></pre></td></tr></table></figure><h3 id="启动和停止容器操作"><a href="#启动和停止容器操作" class="headerlink" title="启动和停止容器操作"></a>启动和停止容器操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id#启动容器</span><br><span class="line">docker restart 容器id#重启容器</span><br><span class="line">docker stop 容器id#停止正在运行的容器</span><br><span class="line">docker kill 容器id#强制停止当前容器</span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit#直接容器停止并退出</span><br><span class="line">Ctrl + P + Q#容器不停止退出</span><br></pre></td></tr></table></figure><h3 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h3><p>后台启动容器（-d）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker run -d 镜像名</span></span><br><span class="line">[root@SJW-aliyun ~]# docker run -d centos</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">问题：运行docker ps，发现centos停止了</span></span><br><span class="line"><span class="meta">#</span><span class="bash">原因：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有运用就会自动停止。</span></span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf --tail 条数 容器id</span><br></pre></td></tr></table></figure><p>查看容器中的进程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure><p>查看镜像元数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><p>进入当前正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器修改一些配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">命令（方式一）</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">[root@SJW-aliyun ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">fe1741b3f823   centos    &quot;/bin/bash&quot;   17 seconds ago   Up 16 seconds             crazy_morse</span><br><span class="line">[root@SJW-aliyun ~]# docker exec -it fe1741b3f823 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">[root@SJW-aliyun ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">fe1741b3f823   centos    &quot;/bin/bash&quot;   8 minutes ago   Up 8 minutes             crazy_morse</span><br><span class="line">[root@SJW-aliyun ~]# docker attach fe1741b3f823</span><br><span class="line">[root@fe1741b3f823 /]# </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> 进入容器开启一个新的终端，可以在里面操作（常用）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker attach 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure><p>从容器内拷贝文件到主机上（宿主机）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令</span></span><br><span class="line">docker cp 容器id:容器内路径 宿主机路径</span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line">[root@SJW-aliyun sjw]# docker attach fe1741b3f823进入docker容器</span><br><span class="line">[root@fe1741b3f823 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@fe1741b3f823 /]# cd /home</span><br><span class="line">[root@fe1741b3f823 home]# touch test.java创建文件</span><br><span class="line">[root@fe1741b3f823 home]# ls</span><br><span class="line">test.java</span><br><span class="line">[root@fe1741b3f823 home]# exit退出容器</span><br><span class="line">exit</span><br><span class="line">[root@SJW-aliyun sjw]# docker cp fe1741b3f823:/home/test.java /home/sjw从容器内拷贝文件到主机上</span><br><span class="line">[root@SJW-aliyun sjw]# cd /home/sjw</span><br><span class="line">[root@SJW-aliyun sjw]# ls</span><br><span class="line">test.java</span><br><span class="line">[root@SJW-aliyun sjw]# </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝是一个手动过程，未来可使用 -v 卷的技术。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://i.loli.net/2021/02/22/pnbmUDYPf4tvHjh.png" alt="image-20210222121826673"></p><h1 id="五、练习"><a href="#五、练习" class="headerlink" title="五、练习"></a>五、练习</h1><h2 id="1、部署nginx"><a href="#1、部署nginx" class="headerlink" title="1、部署nginx"></a>1、部署nginx</h2><blockquote><p>拉取nginx镜像，并启动。外部3344端口映射容器内部80端口，访问外部3344间接访问容器80端口。容器相对于小型linux系统</p></blockquote><p><img src="https://i.loli.net/2021/02/22/hGdw69NempZHXDr.png" alt="image-20210222150709816"></p><p>测试：访问3344端口</p><p><img src="https://i.loli.net/2021/02/22/GwfWe3qiZFMgb4H.png" alt="image-20210222151024484"></p><h2 id="2、部署tomcat"><a href="#2、部署tomcat" class="headerlink" title="2、部署tomcat"></a>2、部署tomcat</h2><blockquote><p>拉取tomcat镜像，并启动。</p></blockquote><p><img src="https://i.loli.net/2021/02/22/GwPaIyAUMoHgjx1.png" alt="image-20210222152946214"></p><p>测试：访问tomcat</p><p><img src="https://i.loli.net/2021/02/22/dnmoGaL7KDw3PM8.png" alt="image-20210222153230316"></p><p>==ps：访问结果为404，那是因为tomcat镜像不是完整的默认是最小镜像，不必要的就被剔除掉，保证最小可运行环境！如下==</p><p><img src="https://i.loli.net/2021/02/22/ctPn2pzBShUgZDe.png" alt="image-20210222153654975"></p><h1 id="六、Docker可视化"><a href="#六、Docker可视化" class="headerlink" title="六、Docker可视化"></a>六、Docker可视化</h1><p><strong>什么是portainer？</strong></p><p>Docker图形化管理工具，提供一个后台面板供我们使用！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">--privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><p>测试：外网访问8088，==记住要把阿里云安全组对应的端口号打开！！！==</p><p><img src="https://i.loli.net/2021/02/22/i2ScazGPBgH5ure.png" alt="image-20210222160051724"></p><p>创建一个用户、选择本地连接，下面就是可视化面板</p><p><img src="https://i.loli.net/2021/02/22/txj94mIAPnrifEX.png" alt="image-20210222160435296"></p><h1 id="六、commit镜像"><a href="#六、commit镜像" class="headerlink" title="六、commit镜像"></a>六、commit镜像</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本（镜像）</span><br><span class="line">相当于把原有的镜像经过自己的操作后封装成一个新的镜像</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此命令和git commit命令类似</span></span><br><span class="line">docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名[:TAG]</span><br></pre></td></tr></table></figure><p>==测试==</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、启动一个默认的tomcat</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、这个默认的tomcat是没有webapps运用（访问不了页面），镜像原因，官方的镜像默认webapps下面没有文件！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、将webapps.dist的文件拷贝进webapps里</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、将操作过的容器通过commit提交为一个镜像！以后可直接使用修改过的镜像！！</span></span><br></pre></td></tr></table></figure><p>启动步骤省略，见上文！</p><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210224103550687.png" alt="image-20210224103550687"></p><p><img src="https://i.loli.net/2021/02/24/bty53vwOeSApCEz.png" alt="image-20210224104052076"></p><p>==如果想保存当前容器状态，就可以通过commit来提交，获得一个镜像==</p><h1 id="七、容器数据卷（重点）"><a href="#七、容器数据卷（重点）" class="headerlink" title="==七、容器数据卷（重点）=="></a>==七、容器数据卷（重点）==</h1><h2 id="1、什么是容器数据卷？"><a href="#1、什么是容器数据卷？" class="headerlink" title="1、什么是容器数据卷？"></a>1、什么是容器数据卷？</h2><blockquote><p>docker的理念回顾？</p></blockquote><p>将应用和环境打包成一个镜像！</p><blockquote><p>应用（容器）产生的数据该何去何从？</p></blockquote><p>如果数据都在容器中，那么删除容器的同时，数据也会丢失</p><p>==需要：数据可以持久化==</p><blockquote><p>什么是卷技术？</p></blockquote><p>容器之间可以有一个数据共享的技术！把docker容器中产生的数据同步到本地！</p><p>这就是卷技术！目录挂载，将我们容器的目录挂载到linux（宿主机）上面！！</p><p><img src="https://i.loli.net/2021/02/24/s6GiKWpcq7QVLZE.png" alt="image-20210224110608269"></p><p>==总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！（多个容器挂载到宿主机同一目录）==</p><h2 id="2、使用数据卷（通过命令）"><a href="#2、使用数据卷（通过命令）" class="headerlink" title="2、使用数据卷（通过命令）"></a>2、使用数据卷（通过命令）</h2><blockquote><p>方式一：直接使用命令来挂载 -v</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@SJW-aliyun home]# docker run -it -v /home/test:/home centos /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/24/dha91XtQnxuDANe.png" alt="image-20210224111804641"></p><p>使用 docker inspect命令查看容器详情</p><p><img src="https://i.loli.net/2021/02/24/SCwEaIOJufr1UAl.png" alt="image-20210224112226064"></p><p><strong>测试文件的同步</strong></p><p><img src="https://i.loli.net/2021/02/24/8MwJjxrk9mKoO3S.png" alt="image-20210224114052209"></p><h3 id="实战：安装mysql"><a href="#实战：安装mysql" class="headerlink" title="实战：安装mysql"></a>实战：安装mysql</h3><p>==目标：mysql数据持久化==</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、启动一个mysql容器，需要做数据挂载！需要配置mysql密码！</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 官方测试：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d后台运行 -p 端口映射 -e环境配置 -v卷挂载</span></span><br><span class="line">[root@SJW-aliyun /]# docker run -d -p 8082:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/24/ctn7OVHaEjuIfW2.png" alt="image-20210224171915609"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2、在本地使用Navicat测试连接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地连接阿里云服务器8082端口映射mysql容器3306端口进行访问！记得打开阿里云对应的端口组！</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/24/3VhlnAdxfiS9keB.png" alt="image-20210224172213411"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3、本地创建数据库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 看文件是否挂载成功？</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/24/YRiNS41DXIpyEqv.png" alt="image-20210224172857460"></p><p><img src="https://i.loli.net/2021/02/24/6F54XuHbN8aUG1D.png" alt="image-20210224173045289"></p><blockquote><p>将mysql容器删除，数据还在不在？</p></blockquote><p><img src="https://i.loli.net/2021/02/24/DZq5Rj1SBYTaeCc.png" alt="image-20210224173736250"></p><p>==实践结果：mysql数据持久化成功！文件挂载成功！哈哈哈哈==</p><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的volume（卷）的情况</span></span><br><span class="line">[root@SJW-aliyun _data]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     3eaa24893e76eec6766865aa607f01c6f7e82268383f76b637165bbe93253c64</span><br><span class="line"><span class="meta">#</span><span class="bash">这种就是匿名挂载，我们在-v只写了容器内的路径没有写容器外的路径！！</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">具名挂载</span></span><br><span class="line">-v 卷名:容器内路径</span><br><span class="line">docker run -d -P --name nginx02 -v nginx02:/etc/nginx nginx</span><br><span class="line">[root@SJW-aliyun _data]# docker volume ls</span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     nginx02</span><br></pre></td></tr></table></figure><blockquote><p>查看卷的详情</p></blockquote><p><img src="https://i.loli.net/2021/02/24/lhvYLkT14KIGPF3.png" alt="image-20210224181006405"></p><p>所有的docker容器内的卷，没有指定目录的情况下(具名和匿名挂载)都是在==/var/lib/docker/volumes/xxx/_data==</p><p>通过具名挂载考研方便的找到我们的一个卷，大多数情况使用的是==具名挂载==</p><blockquote><p>如何确定是具名挂载、匿名挂载还是指定路径挂载！</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-v 容器内路径#匿名挂载</span><br><span class="line">-v 卷名：容器内路径  #具名挂载</span><br><span class="line">-v 宿主机 路径：容器内路径#指定路径挂载</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 容器内路径：ro rw 改变读写权限</span></span><br><span class="line">ro：readonly #只读</span><br><span class="line">rw：readwrite #可读可写（默认）</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">一旦设置了容器权限，容器对我们挂载出来的内容就有了限定！</span></span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx:rw nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内无法操作！！</span></span><br></pre></td></tr></table></figure><h2 id="3、使用数据卷（通过DockerFile）"><a href="#3、使用数据卷（通过DockerFile）" class="headerlink" title="3、使用数据卷（通过DockerFile）"></a>3、使用数据卷（通过DockerFile）</h2><blockquote><p>方式二</p></blockquote><p>==DoockerFile就是用来构建docker镜像的文件！ 实质是命令脚本！==</p><p>通过脚本可以生成镜像，镜像是一层一层的，脚本是一个一个的命令，每个命令都是一层！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建一个dockerfile文件，文件随意</span></span><br><span class="line"><span class="meta">#</span><span class="bash">文件中的内容：指令（大写）+参数</span></span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;volume1&quot;,&quot;volume2&quot;]</span><br><span class="line">CMD echo &quot;---end---&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">这里的每个命令都是镜像的一层！</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/25/DEnwckXhBHJsuWV.png" alt="image-20210225093929054"></p><blockquote><p>启动自己创建的镜像</p></blockquote><p>不清楚为什么这里挂载成了一个目录（狗头），问题不大</p><p><img src="https://i.loli.net/2021/02/25/kctjlqUI895KE2a.png" alt="image-20210225095454198"></p><p><strong>这里的挂载肯定是个匿名挂载，只指定了容器内路径</strong></p><p><img src="https://i.loli.net/2021/02/25/Gceutb6jxlyrPUH.png" alt="image-20210225095804926"></p><p>==这个卷和外部肯定有一个同步的目录==</p><blockquote><p>通过docker inspect命令查看容器详情，可查看挂载路径</p></blockquote><p><img src="https://i.loli.net/2021/02/25/xNnCpjkmeROcDBV.png" alt="image-20210225100428286"></p><p>==总结：==</p><p>​    ==使用dockerfile来挂载数据在未来使用得十分多，因为我们通常会构建自己的镜像，如果构建镜像时没有挂载卷，要手动镜像挂载 -v 容器外路径:容器内路径！！==</p><h2 id="4、数据卷容器"><a href="#4、数据卷容器" class="headerlink" title="4、数据卷容器"></a>4、数据卷容器</h2><blockquote><p>数据卷容器解决什么问题？</p></blockquote><p><strong>解决多个容器之间数据同步问题</strong></p><h1 id="八、DockerFile"><a href="#八、DockerFile" class="headerlink" title="八、DockerFile"></a>八、DockerFile</h1><h2 id="1、dockerfile介绍"><a href="#1、dockerfile介绍" class="headerlink" title="1、dockerfile介绍"></a>1、dockerfile介绍</h2><blockquote><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p></blockquote><p>==构建步骤：==</p><p>1、编写一个dockerfile文件</p><p>2、dockerfile build 构建成为一个镜像</p><p>3、docker run 运行镜像</p><p>4、docker push 发布镜像（DockerHub、阿里云镜像仓库）</p><blockquote><p>查看官方是怎么做的</p></blockquote><p><img src="https://i.loli.net/2021/02/25/mZEnaTOwhpLICik.png" alt="image-20210225124424824"></p><p><img src="https://i.loli.net/2021/02/25/x7NlpwRYbZVfJWK.png" alt="image-20210225124440887"></p><p><strong>发现官方的镜像实质也是一个dockerfile</strong></p><p>==很多官方镜像都是基础包，很多功能没有，我们通常会搭建自己的镜像！==</p><h2 id="2、dockerfile构建过程"><a href="#2、dockerfile构建过程" class="headerlink" title="2、dockerfile构建过程"></a>2、dockerfile构建过程</h2><p><strong>基础知识：</strong></p><p>1、每个保留关键字（指令）都必须是大写字母</p><p>2、执行顺序从上到下</p><p>3、#表示注释</p><p>4、每个指令都会创建提交一个新的镜像层，并提交！</p><p><img src="https://i.loli.net/2021/02/25/jvCtOT2o9zi4YSw.png" alt="image-20210225125409723"></p><p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，文件十分简单！</p><p>docker镜像逐渐成为企业交付的标准，必须要掌握！</p><h2 id="3、dockerfile指令"><a href="#3、dockerfile指令" class="headerlink" title="3、dockerfile指令"></a>3、dockerfile指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM#基础镜像，一切从这里开始构建</span><br><span class="line">MAINTAINER#镜像是谁写的，姓名+邮箱</span><br><span class="line">RUN#镜像构建时需要运行的命令</span><br><span class="line">ADD#添加内容</span><br><span class="line">WORKDIR#镜像的工作目录</span><br><span class="line">VOLUME#挂载的目录</span><br><span class="line">EXPOSE#保留端口配置</span><br><span class="line">CMD#指定容器启动时运行的命令，只有最后一个会生效，可被代替</span><br><span class="line">ENTRYPOINT#指定容器启动时运行的命令，可追加命令</span><br><span class="line">ONBUILD#当构建一个被继承Dockerfile，这个时候就会运行ONBUILD指令。触发指令</span><br><span class="line">COPY#类似ADD，将我们文件拷贝到镜像中</span><br><span class="line">ENY#构建时设置环境变量，例如mysql密码</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/25/Exuyz3dJqCieZTM.png" alt="image-20210225133308729"></p><h2 id="4、实战测试"><a href="#4、实战测试" class="headerlink" title="4、实战测试"></a>4、实战测试</h2><blockquote><p>官方的centos是简化版，很多东西不全，不如vim命令</p></blockquote><p><img src="https://i.loli.net/2021/02/25/Bdx4lpEUajOIRHX.png" alt="image-20210225163829635"></p><blockquote><p>通过dockerfile创建自己的镜像，在官方原有镜像的基础上添加vim</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、编写dockerfile文件</span></span><br><span class="line">[root@SJW-aliyun dockerfile]# vim mydockerfile-centos</span><br><span class="line">[root@SJW-aliyun dockerfile]# cat mydockerfile-centos </span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER sjw&lt;2855289411&gt;</span><br><span class="line">EVN MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、通过文件构建镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令：docker build -f dockerfile文件路径 -t 镜像名[:TAG] .</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、测试运行</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/25/ADvWkhHRmMbVdXo.png" alt="image-20210225165707240"></p><p><img src="https://i.loli.net/2021/02/25/dwAIgJ8pTshD2ay.png" alt="image-20210225165908727"></p><p>==测试成功！！！==</p><blockquote><p>我们可以列出本地镜像的变更历史（docker history 镜像id）</p></blockquote><p><img src="https://i.loli.net/2021/02/25/pcO4FJnrQhmxkqV.png" alt="image-20210225170227228"></p><h2 id="5、实战：Tomcat镜像"><a href="#5、实战：Tomcat镜像" class="headerlink" title="5、实战：Tomcat镜像"></a>5、实战：Tomcat镜像</h2><h1 id="八、发布镜像"><a href="#八、发布镜像" class="headerlink" title="八、发布镜像"></a>八、发布镜像</h1><h2 id="1、发布到DockerHub"><a href="#1、发布到DockerHub" class="headerlink" title="1、发布到DockerHub"></a>1、发布到DockerHub</h2><p>==步骤：==</p><p>1、在dockerhub官网注册自己的帐号！</p><p>2、确定账户可以登陆</p><p>3、在自己的阿里云上登陆docker</p><blockquote><p>命令：docker login</p></blockquote><p><img src="C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210226104132151.png" alt="image-20210226104132151"></p><p>4、登陆成功后就可以发布镜像</p><blockquote><p>命令：docker push</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Docker基本组成&quot;&gt;&lt;a href=&quot;#一、Docker基本组成&quot; class=&quot;headerlink&quot; title=&quot;一、Docker基本组成&quot;&gt;&lt;/a&gt;一、Docker基本组成&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ss0.bdstatic</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/11/30/springboot%E5%88%86%E9%A1%B5/"/>
    <id>http://example.com/2021/11/30/springboot%E5%88%86%E9%A1%B5/</id>
    <published>2021-11-29T17:00:04.517Z</published>
    <updated>2021-12-04T10:45:03.392Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="Springboot分页"><a href="#Springboot分页" class="headerlink" title="Springboot分页"></a>Springboot分页</h2><hr><h3 id="一、分页插件（pagehelper）"><a href="#一、分页插件（pagehelper）" class="headerlink" title="一、分页插件（pagehelper）"></a>一、分页插件（pagehelper）</h3><p>​        之前写项目时都是自己去写分页，头大！自己写的分页很可能要写两次查询，一次查内容，二次查条数。这种就是费力不讨好的事，所以去看了一下pagehelper分页插件（都说是最方便使用的分页插件），学完随便做个笔记。</p><p>​        <strong>pagehelper插件主要是把PageHelper.startPage(pageNum, pageSize)放在sql查询之前。他会去处理查询内容，进行分页处理。</strong></p><h5 id="1、导包"><a href="#1、导包" class="headerlink" title="1、导包"></a>1、导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pagehelper --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、分页请求类"><a href="#2、分页请求类" class="headerlink" title="2、分页请求类"></a>2、分页请求类</h5><p>​        <strong>用于接收请求信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageNum;</span><br><span class="line">    <span class="comment">//每页数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">    <span class="comment">//查询条件</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; params = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h5><ol><li><p>控制层</p><p>​        这里就是接收前端的json数据将其映射成pageRequest对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    QuestionService questionService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/selectQuestions&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;分页查询题库&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo&lt;Question&gt; <span class="title">selectQuestions</span><span class="params">(<span class="meta">@RequestBody</span> PageRequest pageRequest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> questionService.selectQuestions(pageRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层</p><p>​        在service层中pagehelper插件会去实现分页效果。</p><p>​        <strong>主要语句：PageHelper.startPage(pageNum, pageSize)。它要放在查询sql的前面就对该查询结果有效。</strong></p><p>​        PageInfo：是该插件提供的一个返回类，可以封装查询的分页信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionServiceImpl</span> <span class="keyword">implements</span> <span class="title">QuestionService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    QuestionDao questionDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用分页插件完成分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo&lt;Question&gt; <span class="title">selectQuestions</span><span class="params">(PageRequest pageRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pageNum = pageRequest.getPageNum();</span><br><span class="line">        <span class="keyword">int</span> pageSize = pageRequest.getPageSize();</span><br><span class="line">        PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">        List&lt;Question&gt; questionList = questionDao.selectQuestions(pageRequest.getParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageInfo&lt;Question&gt;(questionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dao层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuestionDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询试题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params：查询条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Question&gt; <span class="title">selectQuestions</span><span class="params">(<span class="meta">@Param(&quot;params&quot;)</span> Map&lt;String,Object&gt; params)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        mapper.xml中用<foreach>语句拼接查询条件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybati.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$&#123;&#125;不带&#x27;&#x27;,#&#123;&#125;自带引号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sjw.zxks.dao.QuestionDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectQuestions&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sjw.zxks.pojo.Question&quot;</span>&gt;</span></span><br><span class="line">        select * from question</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;params != null&quot;</span>&gt;</span></span><br><span class="line">            where</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;params&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;and&quot;</span> <span class="attr">index</span>=<span class="string">&quot;key&quot;</span>  <span class="attr">item</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">                $&#123;key&#125; = $&#123;value&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="4、接口测试"><a href="#4、接口测试" class="headerlink" title="4、接口测试"></a>4、接口测试</h5><p> <img src="https://gitee.com/coder-SJW/blogimg/raw/master/img/image-20210126151605884.png" alt="image-20210126151605884"></p><p>   <img src="https://gitee.com/coder-SJW/blogimg/raw/master/img/image-20210126151605884.png" alt="image-20210126151626505"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;Springboot分页&quot;&gt;&lt;a href=&quot;#Springboot分页&quot; class=&quot;headerlink&quot; title=&quot;Springboot分页&quot;&gt;&lt;/a&gt;Springboot分页&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;一、分页插件（pagehelp</summary>
      
    
    
    
    
  </entry>
  
</feed>

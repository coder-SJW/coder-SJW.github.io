<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coder-S</title>
  
  
  <link href="http://tosjw.cn/atom.xml" rel="self"/>
  
  <link href="http://tosjw.cn/"/>
  <updated>2022-06-18T02:17:41.132Z</updated>
  <id>http://tosjw.cn/</id>
  
  <author>
    <name>coder-S</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>好文</title>
    <link href="http://tosjw.cn/2022/03/15/%E5%A5%BD%E6%96%87/"/>
    <id>http://tosjw.cn/2022/03/15/%E5%A5%BD%E6%96%87/</id>
    <published>2022-03-15T08:08:41.000Z</published>
    <updated>2022-06-18T02:17:41.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><p><a href="https://xie.infoq.cn/article/fc4650192fd4e6ac37f6dadbc">动图图解 GC 算法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm&quot;&gt;&lt;a href=&quot;#jvm&quot; class=&quot;headerlink&quot; title=&quot;jvm&quot;&gt;&lt;/a&gt;jvm&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://xie.infoq.cn/article/fc4650192fd4e6ac37f6dadbc&quot;&gt;动</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>&#39;javax.validation:validation-api常用注解&#39;</title>
    <link href="http://tosjw.cn/2022/02/25/javaxvalidation%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>http://tosjw.cn/2022/02/25/javaxvalidation%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-02-25T08:11:35.000Z</published>
    <updated>2022-06-18T03:12:51.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>在我们应用程序的业务逻辑中，经常会碰到参数校验的情况，手动的在代码层上面进行校验就会带来很不好的体验，阅读、维护的成本会大大增加，造成冗余。因此有了这个JSR 303。</p><p>Bean Validation为JavaBean提供了相应的API来给我们做参数的验证。通过Bean Validation比如@NotNull @Pattern等方法来对我们字段的值做进一步的教研。</p><p>Bean Validation 是一个运行时框架，在验证之后错误信息会直接返回。</p><p>完整的jar包：<br>javax.validation:validation-api:2.0.1.Final.jar 包</p><blockquote><p>注意：SpringBoot2 项目web组件已经内置了这个依赖了</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="二、常用验证注解"><a href="#二、常用验证注解" class="headerlink" title="二、常用验证注解"></a>二、常用验证注解</h1><h2 id="NotEmpty"><a href="#NotEmpty" class="headerlink" title="@NotEmpty"></a>@NotEmpty</h2><p> 不能为null，而且长度必须大于0（一般注解在<strong>集合</strong>属性上）</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220225162411902.png" alt="img"></p><h2 id="NotBlank"><a href="#NotBlank" class="headerlink" title="@NotBlank"></a>@NotBlank</h2><p>@NotBlank<strong>只用于String</strong>,不能为null且trim()之后size&gt;0</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220225162425290.png" alt="img"></p><h2 id="NotNull"><a href="#NotNull" class="headerlink" title="@NotNull"></a>@NotNull</h2><p>不能为null，但可以为empty；用在基本类型上</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220225162453346.png" alt="img"></p><blockquote><p>例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull(message = &quot;用户id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;studentId不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String studentId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;课程id不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; courseIdS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、-Valid和-Validated的区分"><a href="#三、-Valid和-Validated的区分" class="headerlink" title="三、@Valid和@Validated的区分"></a>三、@Valid和@Validated的区分</h1><h2 id="1、-Valid"><a href="#1、-Valid" class="headerlink" title="1、@Valid"></a>1、@Valid</h2><blockquote><p>@Valid注解用于校验，所属包为：javax.validation.Valid。</p></blockquote><p>①、首先需要在实体类的相应字段上添加用于充当校验条件的注解，如：@Min,如下代码（age属于Girl类中的属性）：如上图</p><p>②、其次在controller层的方法的要校验的参数上添加@Valid注解，并且需要传入BindingResult对象，用于获取校验失败情况下的反馈信息，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/girls&quot;)</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Girl <span class="title">addGirl</span><span class="params">(<span class="meta">@Valid</span> Girl girl, BindingResult bindingResult)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;  </span><br><span class="line">        System.out.println(bindingResult.getFieldError().getDefaultMessage());  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> girlResposity.save(girl);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>bindingResult.getFieldError.getDefaultMessage()用于获取相应字段上添加的message中的内容</p></blockquote><h2 id="2、-Validated"><a href="#2、-Validated" class="headerlink" title="2、@Validated"></a>2、@Validated</h2><blockquote><p>@Valid是javax.validation里的。</p><p>@Validated是@Valid 的一次封装，<strong>是Spring提供的校验机制使用</strong>，所属包: org.springframework.validation.annotation.Validated。</p></blockquote><h1 id="四、使用例子"><a href="#四、使用例子" class="headerlink" title="四、使用例子"></a>四、使用例子</h1><p>未完待续…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;在我们应用程序的业务逻辑中，经常会碰到参数校验的情况，手动的在代码层上面进行校验就会带来很不好的体验，阅读、维护的成本会大大</summary>
      
    
    
    
    <category term="java" scheme="http://tosjw.cn/categories/java/"/>
    
    
    <category term="常用注解" scheme="http://tosjw.cn/tags/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务</title>
    <link href="http://tosjw.cn/2022/02/24/Mysql%E4%BA%8B%E5%8A%A1/"/>
    <id>http://tosjw.cn/2022/02/24/Mysql%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-02-24T03:08:27.000Z</published>
    <updated>2022-06-18T03:16:07.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是事务？"><a href="#1、什么是事务？" class="headerlink" title="1、什么是事务？"></a>1、什么是事务？</h2><blockquote><p>在mysql中，事务是一组原子性的sql语句，或者说是一个独立的工作单元</p></blockquote><p><strong>事务有四个特性：</strong></p><ul><li><p>原子性(Atomicity)：一个事务必须被视为不可分割的最小工作单位</p></li><li><p>一致性(Consistency)</p></li><li><p>隔离型(Isolation)</p></li><li><p>持久性(Durability)</p></li></ul><h2 id="2、redo-log-与-undo-log"><a href="#2、redo-log-与-undo-log" class="headerlink" title="2、redo log 与 undo log"></a>2、redo log 与 undo log</h2><p><a href="https://www.yisu.com/zixun/131492.html">如何查看日志</a></p><h3 id="①redo-log"><a href="#①redo-log" class="headerlink" title="①redo log"></a>①redo log</h3><p>​    redo log叫做重做日志，用来实现事务的持久性。该日志文件由两部分组成：<strong>重做日志缓冲（redo log buffer）以及重做日志文件（redo log）</strong>,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。</p><blockquote><p>redo log 有什么作用？</p></blockquote><p>​        mysql 为了提升性能<strong>不会把每次的修改都实时同步到磁盘</strong>，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后<strong>使用后台线程去做缓冲池和磁盘之间的同步</strong>。</p><blockquote><p>总结：redo log是用来恢复数据的，用于保障已提交事务的持久化特性。</p></blockquote><h3 id="②undo-log"><a href="#②undo-log" class="headerlink" title="②undo log"></a>②undo log</h3><p>​        undo log 叫做回滚日志，用于记录数据被修改前的信息。<strong>他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息</strong>。undo  log主要记录的是数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p><blockquote><p>undo log 有什么作用？</p></blockquote><p>​        <strong>undo log 记录事务修改之前版本的数据信息</strong>，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。</p><blockquote><p>总结：undo log是用来回滚数据的，用于保障未提交事务的原子性</p></blockquote><h2 id="3、事务的实现"><a href="#3、事务的实现" class="headerlink" title="3、事务的实现"></a>3、事务的实现</h2><h3 id="①原子性的实现"><a href="#①原子性的实现" class="headerlink" title="①原子性的实现"></a>①原子性的实现</h3><blockquote><p>undo log 的生成</p></blockquote><p>每条数据变更(insert/update/delete)操作都<strong>伴随一条undo log的生成</strong>,并且<strong>回滚日志必须先于数据持久化到磁盘上</strong></p><p>所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</p><p>根据undo log 进行回滚回滚操作就是要还原到原来的状态，undo log记录了数据被修改前的信息以及新增和被删除的数据信息，根据undo log生成回滚语句，比如：</p><p>(1) 如果在回滚日志里有新增数据记录，则生成删除该条的语句</p><p>(2) 如果在回滚日志里有删除数据记录，则生成生成该条的语句</p><p>(3) 如果在回滚日志里有修改数据记录，则生成修改到原先数据的语句</p><h3 id="②持久性的实现"><a href="#②持久性的实现" class="headerlink" title="②持久性的实现"></a>②持久性的实现</h3><p>事务一旦提交，其所作做的修改会永久保存到数据库中，<strong>此时即使系统崩溃修改的数据也不会丢失</strong>。</p><p>MySQL的表数据是存放在磁盘上的，因此想要存取的时候都要经历磁盘IO,然而即使是使用SSD磁盘IO也是非常消耗性能的。为此，为了提升性能InnoDB提供了缓冲池(Buffer Pool)，Buffer Pool中包含了磁盘数据页的映射，可以当做缓存来使用：</p><p>读数据：会首先从缓冲池中读取，如果缓冲池中没有，则从磁盘读取在放入缓冲池；</p><p>写数据：会首先写入缓冲池，缓冲池中的数据会定期同步到磁盘中</p><h3 id="③隔离性的实现-相对复杂"><a href="#③隔离性的实现-相对复杂" class="headerlink" title="③隔离性的实现(相对复杂)"></a>③隔离性的实现(相对复杂)</h3><blockquote><p>隔离性是事务ACID特性里最复杂的一个</p></blockquote><p>​        在SQL标准里定义了四种隔离级别，每一种级别都规定一个事务中的修改，哪些是事务之间可见的，哪些是不可见的。级别越低的隔离级别可以执行越高的并发，但同时实现复杂度以及开销也越大。</p><p>Mysql 隔离级别有以下四种(低–&gt;高）：未提交读（Read uncommitted）、已提交读（Read committed）、可重复读（Repeatable read）、串行化（<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&chksm=80d66e7ab7a1e76c8f8b7be95b8617aba9c4d76c6f95fbedd8d222f6c8912d49686902af7bca&idx=1&mid=2665518649&scene=21&sn=1c2fa1986acf7b8ee0e5a14fbb3da9ae#wechat_redirect">Serializable</a> ）</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220224135105016.png" alt="img"></p><p>​        只要彻底理解了隔离级别以及他的实现原理就相当于理解了ACID里的隔离型。<strong>前面说过原子性，隔离性，持久性的目的都是为了要做到一致性</strong>，但隔离性跟其他两个有所区别，原子性和持久性是为了要实现数据的可性保障靠，比如要做到宕机后的恢复，以及错误后的回滚。</p><blockquote><p>如果不考虑隔离性，会发生什么事呢？</p></blockquote><blockquote><p>1、脏读</p></blockquote><p>是指一个事务在处理数据的过程中，读取到另一个为提交事务的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION；</span><br><span class="line">updata t_table <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;wangwu&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">--此时事务2查询id = 1</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>；</span><br><span class="line"> </span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;        <span class="comment">--查询到 id = 1， name = &#x27;wangwu&#x27;</span></span><br></pre></td></tr></table></figure><p>​        事务1并没有提交,开始只会写入缓冲池，未持久化到磁盘，name 还是 lisi，但是事务2却读到了 name = wangwu，这就是脏读。如果换成A给B转账，B查询到了没有提交的事务，认为已经收到A转过来的钱，那岂不是很恐怖。</p><blockquote><p>2、不可重复读</p></blockquote><p>​        不可重复读是指对于数据库中的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另外一个事务修改并提交了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = list, 事务2在此时提交</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">-- 查询到 id = 1, name = wangwu</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">update t_table <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;wangwu&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>不可重复读和脏读的区别是:</p><ul><li><p>脏读读取到的是一个<strong>未提交的数据</strong></p></li><li><p>不可重复读读取到的是前一个事务<strong>提交的数据</strong></p></li></ul><blockquote><p>3、幻读</p></blockquote><p>​        幻读是事务非独立执行时发生的一种现象</p><p>​        例如事务1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><p>​        幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--原数据</span></span><br><span class="line"><span class="comment">--id    name</span></span><br><span class="line"><span class="comment">--1     lisi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">--事务1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;    <span class="comment">--返回NULL,此时事务2提交</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;    <span class="comment">--返回id = 2, name = wangwu</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">--事务2</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_table <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;wangwu&#x27;</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>​        不可重复读和幻读是初学者不易分清的概念，我也是看了详细的解读才明白的，总的来说，解决不可重复读的方法是 <strong>锁行</strong>，解决幻读的方式是 <strong>锁表</strong>。</p><blockquote><p>查询和设置数据库的隔离级别</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;隔离级别&#x27;</span>;    <span class="comment">--read-uncommitted    read-committed    repeatable-read    serializable</span></span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;read-uncommitted&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> READ<span class="operator">-</span>UNCOMMITTED <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、什么是事务？&quot;&gt;&lt;a href=&quot;#1、什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是事务？&quot;&gt;&lt;/a&gt;1、什么是事务？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在mysql中，事务是一组原子性的sql语句，或者说是一个独立的工</summary>
      
    
    
    
    <category term="mysql" scheme="http://tosjw.cn/categories/mysql/"/>
    
    
    <category term="mysql事务" scheme="http://tosjw.cn/tags/mysql%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>java简洁编码</title>
    <link href="http://tosjw.cn/2022/02/23/java%E7%AE%80%E6%B4%81%E7%BC%96%E7%A0%81/"/>
    <id>http://tosjw.cn/2022/02/23/java%E7%AE%80%E6%B4%81%E7%BC%96%E7%A0%81/</id>
    <published>2022-02-23T09:46:17.000Z</published>
    <updated>2022-06-18T03:15:02.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、方法"><a href="#一、方法" class="headerlink" title="一、方法"></a>一、方法</h1><h2 id="1、方法不要返回-null"><a href="#1、方法不要返回-null" class="headerlink" title="1、方法不要返回 null"></a>1、方法不要返回 null</h2><p><strong>别处调用方法时，避免不必要的空指针</strong></p><blockquote><p>反例：</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220223175053632.png" alt="img"></p><blockquote><p>正例：</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220223175109480.png" alt="img"></p><h2 id="2、总是在-Switch-语句的-Default-中抛出异常"><a href="#2、总是在-Switch-语句的-Default-中抛出异常" class="headerlink" title="2、总是在 Switch 语句的 Default 中抛出异常"></a>2、总是在 Switch 语句的 Default 中抛出异常</h2><blockquote><p>当 value == 3 时，将会出现无法找到的提示，而不会让人不知所谓。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: foo(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: bar(); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: foo(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: bar(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ThreadDeath(<span class="string">&quot;That&#x27;ll teach them&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、常量与变量"><a href="#二、常量与变量" class="headerlink" title="二、常量与变量"></a>二、常量与变量</h1><h2 id="1、如果变量的初值会被覆盖，就没有必要给变量赋初值"><a href="#1、如果变量的初值会被覆盖，就没有必要给变量赋初值" class="headerlink" title="1、如果变量的初值会被覆盖，就没有必要给变量赋初值"></a>1、如果变量的初值会被覆盖，就没有必要给变量赋初值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">List&lt;UserDO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">List&lt;UserDO&gt; userList;</span><br><span class="line"><span class="keyword">if</span> (isAll) &#123;</span><br><span class="line">    userList = userDAO.queryAll();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    userList = userDAO.queryActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、尽量使用移位来代替正整数乘除"><a href="#2、尽量使用移位来代替正整数乘除" class="headerlink" title="2、尽量使用移位来代替正整数乘除"></a>2、尽量使用移位来代替正整数乘除</h2><blockquote><p>用移位操作可以极大地提高性能。对于乘除2^n(n为正整数)的正整数计算，可以用移位操作来代替。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">int</span> num1 = a * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = a / <span class="number">4</span>;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">int</span> num1 = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = a &gt;&gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h1 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h1><h2 id="1、尽量使用StringBuilder进行字符串拼接"><a href="#1、尽量使用StringBuilder进行字符串拼接" class="headerlink" title="1、尽量使用StringBuilder进行字符串拼接"></a>1、尽量使用StringBuilder进行字符串拼接</h2><blockquote><p> String是final类，内容不可修改，所以每次字符串拼接都会生成一个新对象。StringBuilder在初始化时申请了一块内存，以后的字符串拼接都在这块内存中执行，不会申请新内存和生成新对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        s += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、不要使用””-转化字符串"><a href="#2、不要使用””-转化字符串" class="headerlink" title="2、不要使用””+转化字符串"></a>2、不要使用””+转化字符串</h2><blockquote><p>使用””+进行字符串转化方便但是<strong>效率低</strong>，建议使用String.valueOf()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line">String s = <span class="string">&quot;&quot;</span> + i;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">12345</span>;</span><br><span class="line">String s = String.valueOf(i);</span><br></pre></td></tr></table></figure><h2 id="3、字符串比较，将-String-字符串放在最前面"><a href="#3、字符串比较，将-String-字符串放在最前面" class="headerlink" title="3、字符串比较，将 String 字符串放在最前面"></a>3、字符串比较，将 String 字符串放在最前面</h2><blockquote><p>为了防止偶发性的 NullPointerException 异常，通常将 String 放置在 equals() 函数的左边来实现字符串比较，如下代码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">if</span> (variable.equals(<span class="string">&quot;literal&quot;</span>)) &#123; ... &#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;literal&quot;</span>.equals(variable)) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h1 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h1><h2 id="1、初始化集合时，尽量指定集合大小"><a href="#1、初始化集合时，尽量指定集合大小" class="headerlink" title="1、初始化集合时，尽量指定集合大小"></a>1、初始化集合时，尽量指定集合大小</h2><blockquote><p>Java集合初始化时都会指定一个默认大小，当默认大小不再满足数据需求时就会扩容，每次扩容的时间复杂度有可能是O(n)。所以，尽量指定预知的集合大小，就能<strong>避免或减少集合的扩容次数</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line">Set&lt;Long&gt; userSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;UserVO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    userSet.add(userDO.getId());</span><br><span class="line">    userMap.put(userDO.getId(), userDO);</span><br><span class="line">    userList.add(transUser(userDO));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">List&lt;UserDO&gt; userDOList = ...;</span><br><span class="line"><span class="keyword">int</span> userSize = userDOList.size();</span><br><span class="line">Set&lt;Long&gt; userSet = <span class="keyword">new</span> HashSet&lt;&gt;(userSize);</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;((<span class="keyword">int</span>) Math.ceil(userSize * <span class="number">4.0</span> / <span class="number">3</span>));</span><br><span class="line">List&lt;UserVO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;(userSize);</span><br><span class="line"><span class="keyword">for</span> (UserDO userDO : userDOList) &#123;</span><br><span class="line">    userSet.add(userDO.getId());</span><br><span class="line">    userMap.put(userDO.getId(), userDO);</span><br><span class="line">    userList.add(transUser(userDO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合"><a href="#2、不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合" class="headerlink" title="2、不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合"></a>2、不要使用循环拷贝集合，尽量使用JDK提供的方法拷贝集合</h2><blockquote><p>JDK提供的<a href="https://www.runoob.com/java/java-arraylist-addall.html">方法</a><strong>可以一步指定集合的容量，避免多次扩容浪费时间和空间</strong>。同时，这些方法的底层也是调用System.arraycopy方法实现，进行数据的批量拷贝效率更高。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">List&lt;UserDO&gt; user1List = ...;</span><br><span class="line">List&lt;UserDO&gt; user2List = ...;</span><br><span class="line">List&lt;UserDO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;(user1List.size() + user2List.size());</span><br><span class="line"><span class="keyword">for</span> (UserDO user1 : user1List) &#123;</span><br><span class="line">    userList.add(user1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (UserDO user2 : user2List) &#123;</span><br><span class="line">    userList.add(user2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">List&lt;UserDO&gt; user1List = ...;</span><br><span class="line">List&lt;UserDO&gt; user2List = ...;</span><br><span class="line">List&lt;UserDO&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;(user1List.size() + user2List.size());</span><br><span class="line">userList.addAll(user1List);</span><br><span class="line">userList.addAll(user2List);</span><br></pre></td></tr></table></figure><h2 id="3、不要使用size方法检测空，必须使用isEmpty方法检测空"><a href="#3、不要使用size方法检测空，必须使用isEmpty方法检测空" class="headerlink" title="3、不要使用size方法检测空，必须使用isEmpty方法检测空"></a>3、不要使用size方法检测空，必须使用isEmpty方法检测空</h2><blockquote><p>使用size方法来检测空逻辑上没有问题，但使用isEmpty方法使得代码更易读，并且可以获得更好的性能。**任何isEmpty方法实现的时间复杂度都是O(1)，但是某些size方法实现的时间复杂度有可能是O(n)**。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line">List&lt;UserDO&gt; userList = ...;</span><br><span class="line"><span class="keyword">if</span> (userList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">if</span> (userMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good</span></span><br><span class="line">List&lt;UserDO&gt; userList = ...;</span><br><span class="line"><span class="keyword">if</span> (userList.isEmpty()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;Long, UserDO&gt; userMap = ...;</span><br><span class="line"><span class="keyword">if</span> (userMap.isEmpty()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Optional判null"><a href="#4、Optional判null" class="headerlink" title="4、Optional判null"></a>4、Optional判null</h2><p><a href="https://www.runoob.com/java/java8-optional-class.html">java8新特性 Optional</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取子目录列表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CatalogueTreeNode&gt; <span class="title">getChild</span><span class="params">(String pid)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (V.isEmpty(pid)) &#123;</span><br><span class="line">            pid = BasicDic.TEMPORARY_DIRECTORY_ROOT;</span><br><span class="line">        &#125;</span><br><span class="line">        CatalogueTreeNode node = treeNodeMap.get(pid);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(node)</span><br><span class="line">                .map(CatalogueTreeNode::getChild)</span><br><span class="line">                .orElse(Collections.emptyList()); <span class="comment">//orElse(T other):如果存在该值，返回值， 否则返回 other。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Optional.ofNullable(node)</p></blockquote><h2 id="5、-推荐-CollectionUtils判null、空"><a href="#5、-推荐-CollectionUtils判null、空" class="headerlink" title="5、(推荐)CollectionUtils判null、空"></a>5、(推荐)CollectionUtils判null、空</h2><blockquote><p>CollectionUtils属于org.apache.commons</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220225113354421.png" alt="img"></p><blockquote><p>CollectionUtils.isEmpty()方法源码</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220225113252878.png" alt="img"></p><blockquote><p>如果直接使用list.isEmpty(),list为null就会抛异常；ColletionsUtils里面也判断了isEmpty，但为什么他没报错呢？</p></blockquote><p>我们都知道&amp;&amp;和||都是短路模式，&amp;&amp;必须两个都为正确(true)，才会返回正确，只要第一个为false，则下面的不执行，直接返回错误。而||则是只要第一个返回true，则后面的就不再执行。</p><p>所以：他是在先判断isEmpty之前判断的是否为null，并且用的短路模式，||当前面的为正确(true)，则后面的isEmpty则不会运行，直接返回正确，从而业务能正常运行下去，<strong>不会报空异常</strong>。</p><h1 id="五、框架"><a href="#五、框架" class="headerlink" title="五、框架"></a>五、框架</h1><h2 id="1、用-RequiredArgsConstructor代替-Autowired"><a href="#1、用-RequiredArgsConstructor代替-Autowired" class="headerlink" title="1、用@RequiredArgsConstructor代替@Autowired"></a>1、用@RequiredArgsConstructor代替@Autowired</h2><blockquote><p>@RequiredArgsConstructor：lombok提供</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220223174838495.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、方法&quot;&gt;&lt;a href=&quot;#一、方法&quot; class=&quot;headerlink&quot; title=&quot;一、方法&quot;&gt;&lt;/a&gt;一、方法&lt;/h1&gt;&lt;h2 id=&quot;1、方法不要返回-null&quot;&gt;&lt;a href=&quot;#1、方法不要返回-null&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="java" scheme="http://tosjw.cn/categories/java/"/>
    
    
    <category term="编码规范" scheme="http://tosjw.cn/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>GitfLow</title>
    <link href="http://tosjw.cn/2022/02/16/GitfLow/"/>
    <id>http://tosjw.cn/2022/02/16/GitfLow/</id>
    <published>2022-02-16T02:31:01.000Z</published>
    <updated>2022-06-18T03:07:43.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是gitFlow工作流"><a href="#一、什么是gitFlow工作流" class="headerlink" title="一、什么是gitFlow工作流"></a>一、什么是gitFlow工作流</h1><blockquote><p>Gitflow 实际上只是 Git 工作流程的抽象概念。这意味着它规定了要设置什么样的分支以及如何将它们合并在一起。</p></blockquote><blockquote><p> gitFlow流程图：</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/64ef2ae7ec855b09cfb851d11ed32f9d.png" alt="img"></p><p>我们将在下面讨论分支的目的。 git-flow 工具集是一个具有安装过程的实际命令行工具。 git-flow 的安装过程很简单。 git-flow  的软件包可在多个操作系统上使用。</p><ul><li>在 OSX 系统上，您可以执行 brew install git-flow。</li><li>在 Windows  上，您需要下载并安装 git-flow。安装 git-flow 后，您可以通过执行 git flow init 在项目中使用它.Git-flow 是一个围绕 Git 的包装器。 git flow init 命令是默认 git init  命令的扩展，除了为您创建分支外，不会更改存储库中的任何内容 #</li></ul><h1 id="二、操作"><a href="#二、操作" class="headerlink" title="二、操作"></a>二、操作</h1><h2 id="1-（Feature-branches）功能分支"><a href="#1-（Feature-branches）功能分支" class="headerlink" title="1.（Feature branches）功能分支"></a>1.（Feature branches）功能分支</h2><p>​        每个新功能都应该驻留在自己的分支中，可以将其推送到中央存储库以进行备份/协作。但是，功能分支不是从主分支分支，而是使用开发作为其父分支。当一个功能完成后，它会被合并回develop。功能不应该直接与 main 交互。（如下图）</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/2531f0cc30b7796b46f0c4e1c44cd166.png" alt="img"></p><h3 id="1-1创建功能分支"><a href="#1-1创建功能分支" class="headerlink" title="1.1创建功能分支"></a>1.1创建功能分支</h3><blockquote><p>不使用git-flow进行创建</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop #切换到develop分支</span><br><span class="line">git checkout -b feature_branch #在develop分支上创建功能分支并切换</span><br></pre></td></tr></table></figure><blockquote><p>使用git-flow进行创建</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start feature_branch</span><br></pre></td></tr></table></figure><p>继续你的工作并像往常一样使用 Git。</p><h3 id="1-2完成功能分支"><a href="#1-2完成功能分支" class="headerlink" title="1.2完成功能分支"></a>1.2完成功能分支</h3><blockquote><p>不使用git-flow</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop #切换到develop分支</span><br><span class="line">git merge feature_branch #合并功能分支</span><br></pre></td></tr></table></figure><blockquote><p>使用git-flow</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish feature_branch</span><br></pre></td></tr></table></figure><h2 id="2-（Release-branches）发布分支"><a href="#2-（Release-branches）发布分支" class="headerlink" title="2.（Release branches）发布分支"></a>2.（Release branches）发布分支</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/4e0529e08f5a4f954b5ed8cccf63d960.png" alt="image-20220216112954357"></p><p>​            一旦 develop 获得了足够的发布功能（或预定的发布日期临近），您就可以从 develop  分支分支发布。创建此分支会启动下一个发布周期，因此在此之后不能添加新功能——只有错误修复、文档生成和其他面向发布的任务应该在此分支中进行。一旦准备好发布，发布分支就会合并到 main 中并用版本号标记。此外，它应该重新合并到开发中，这可能自发布启动以来已经取得了进展。  使用专门的分支来准备发布，可以让一个团队完善当前版本，而另一个团队继续为下一个版本开发功能。它还创建了明确定义的开发阶段（例如，很容易说“本周我们正在为版本 4.0 做准备”，并在存储库的结构中实际看到它）。  制作发布分支是另一个简单的分支操作。与特性分支一样，发布分支也是基于开发分支的。可以使用以下方法创建新的发布分支。</p><blockquote><p>不使用git-flow创建发布分支</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop #切换到develop分支</span><br><span class="line">git checkout -b release/0.1.0 # 创建发布分支</span><br></pre></td></tr></table></figure><blockquote><p>使用git-flow创建发布分支</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git flow release start 0.1.0</span><br><span class="line">Switched to a new branch &#x27;release/0.1.0&#x27;</span><br></pre></td></tr></table></figure><p>​        一旦发布分支准备好发布，它将被合并到主分支和开发分支中，<strong>然后发布分支将被删除</strong>。<strong>重新合并到开发中很重要</strong>，因为可能已将关键更新添加到发布分支中，并且需要新功能可以访问它们。</p><blockquote><p>不使用git-flow合并发布分支到主分支</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main #切换到主分支</span><br><span class="line">git merge release/0.1.0 #合并发布分支</span><br></pre></td></tr></table></figure><blockquote><p>使用git-flow合并发布分支到主分支</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish &#x27;0.1.0&#x27;</span><br></pre></td></tr></table></figure><h2 id="3-（Hotfix-branches）修复分支"><a href="#3-（Hotfix-branches）修复分支" class="headerlink" title="3.（Hotfix branches）修复分支"></a>3.（Hotfix branches）修复分支</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/e3fce349f1969f18fef2850b6fbfb33c.png" alt="image-20220222111836746"></p><p>​        这个分支用来修复主线master的BUG。修复分支很像发布分支和功能分支，只是它们基于main分支而不是develop分支。这是唯一应该直接从 main  分叉的分支。修复完成后，应将其合并到 main分支 和 develop分支（或当前发布分支）中，并且 main 分支应使用更新的版本号进行标记。拥有专门的错误修复开发线可以让您的团队解决问题，而无需中断工作流程的其余部分或等待下一个发布周期。您可以将修复分支视为直接与 main分支  一起使用的临时发布分支。</p><p>可以使用以下方法创建修复分支：</p><blockquote><p>不使用git-flow创建</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git checkout -b hotfix_branch</span><br></pre></td></tr></table></figure><blockquote><p>使用git-flow创建</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix start hotfix_branch</span><br></pre></td></tr></table></figure><p>一个修复分支合并到主分支和开发分支中，类似于完成一个发布分支，如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge hotfix_branch</span><br><span class="line">git checkout develop</span><br><span class="line">git merge hotfix_branch</span><br><span class="line">git branch -D hotfix_branch</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git flow hotfix finish hotfix_branch</span><br></pre></td></tr></table></figure><h1 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h1><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/54e38d1c37e1cc043a05b95ad1bfa5ba.png" alt="image-20220222172122699"></p><p>下面的例子将演示Gitflow流程如何被用来管理一次产品发布。假设你已经创建好了一个中央仓库。</p><h2 id="1、创建develop分支"><a href="#1、创建develop分支" class="headerlink" title="1、创建develop分支"></a>1、创建develop分支</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/361bedb826c65f5f2acff56516963174.png" alt="image-20220222173428594"></p><blockquote><p>第一步：是给默认的master配备一个develop分支。一种简单的做法是：让一个开发者在本地建立一个空的develop分支，然后把它推送到服务器。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch develop</span><br><span class="line">git push -u origin develop</span><br></pre></td></tr></table></figure><blockquote><p>第二步：develop分支将包含项目的所有历史，而master会是一个缩减版本。现在，其他开发者应该克隆（clone）中央仓库，并且为develop创建一个追踪分支。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br><span class="line">git checkout -b develop origin/develop</span><br></pre></td></tr></table></figure><h2 id="2、张三和罗翔开始开发新功能"><a href="#2、张三和罗翔开始开发新功能" class="headerlink" title="2、张三和罗翔开始开发新功能"></a>2、张三和罗翔开始开发新功能</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/83e9891841cdfffbcb03a08e48c1560f.png" alt="image-20220222172607442"></p><blockquote><p>第一步：他们俩各自建立了自己的分支。<strong>注意</strong>–&gt;他们在创建分支时，父分支不能选择master，而要选择develop。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b some-feature develop</span><br></pre></td></tr></table></figure><blockquote><p> 第二步：他们俩都在自己的功能开发分支上开展工作。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git add &lt;some-file&gt;</span><br><span class="line">git commit </span><br></pre></td></tr></table></figure><h2 id="3、张三完成了新功能的开发"><a href="#3、张三完成了新功能的开发" class="headerlink" title="3、张三完成了新功能的开发"></a>3、张三完成了新功能的开发</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/9b7ce14f8cf12418ba3b62a839a22696.png" alt="image-20220222173116175"></p><p>​        在提交过几次代码之后，张三觉得她的功能做完了。如果她所在的团队使用“PR”，此刻她可以提出一个将她所完成的功能合并入develop分支的请求。要不然，她可以自行将她的代码合并入本地的develop分支，然后再推送到中央仓库，像这样：</p><blockquote><p>第一条命令确保了本地的develop分支拥有最新的代码——这一步必须在将功能代码合并之前做！<strong>注意</strong>，新开发的功能代码永远不能直接合并入master。必要时，还需要解决在代码合并过程中的冲突。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git pull origin develop</span><br><span class="line">git checkout develop</span><br><span class="line">git merge some-feature</span><br><span class="line">git push</span><br><span class="line">git branch -d some-feature</span><br></pre></td></tr></table></figure><h2 id="4、张三开始预备一次发布"><a href="#4、张三开始预备一次发布" class="headerlink" title="4、张三开始预备一次发布"></a>4、张三开始预备一次发布</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/83faa05bb1371f6da639e4d47cf35f0d.png" alt="image-20220222173714714"></p><p>​        尽管罗翔还在忙着开发他的功能，小马却可以开始准备这个项目的第一次正式发布了。类似于功能开发，她使用了一个新的分支来做产品发布的准备工作。在这一步，发布的版本号也最初确定下来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-0.1 develop</span><br></pre></td></tr></table></figure><p>​        <strong>这个分支专门用于发布前的准备</strong>，包括一些清理工作、全面的测试、文档的更新以及任何其他的准备工作。它与用于功能开发的分支相似，不同之处在于它是专为产品发布服务的。</p><p>​        一旦张三创建了这个分支并把它推向中央仓库，这次产品发布包含的功能也就固定下来了。任何还处于开发状态的功能只能等待下一个发布周期。</p><h2 id="5、张三完成了发布"><a href="#5、张三完成了发布" class="headerlink" title="5、张三完成了发布"></a>5、张三完成了发布</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/19af77188cd5edf372f4cf0313e00557.png" alt="image-20220222174154538"></p><p>​        一切准备就绪之后，张三就要把发布分支合并入<strong>master</strong>和<strong>develop</strong>分支，然后<strong>再将发布分支删除</strong>。<strong>注意</strong>，往develop分支的合并是很重要的，因为开发人员可能在发布分支上修复了一些关键的问题，而这些修复对于正在开发中的新功能是有益的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge release-0.1</span><br><span class="line">git push</span><br><span class="line">git checkout develop</span><br><span class="line">git merge release-0.1</span><br><span class="line">git push</span><br><span class="line">git branch -d release-0.1</span><br></pre></td></tr></table></figure><blockquote><p>发布分支扮演的角色是功能开发（develop）与官方发布（master）之间的一个<strong>缓冲</strong>。无论什么时候你把一些东西合并入master，你都应该随即打上合适的标签。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 0.1 -m&quot;Initial public release&quot; master</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>​        另外：Git支持钩子（hook）的功能，也就是说，在代码仓库里某些特定的事件发生的时候，可以执行一些预定义的脚本。因此，一种可行的做法是：在服务器端配置一个钩子，当你把master推送到中央仓库或者推送标签时，Git服务器能为产品发布进行一次自动的构建。</p><h2 id="6、用户发现了一个bug"><a href="#6、用户发现了一个bug" class="headerlink" title="6、用户发现了一个bug"></a>6、用户发现了一个bug</h2><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/c99da3c8ea18cd4707274b61bfcc569f.png" alt="image-20220222174717774"></p><p>​        当一次发布完成之后，张三便回去与罗翔一起开发其他功能了。突然，某个用户提出抱怨说当前发布的产品里有一个bug。为了解决这个问题，张三（或者罗翔）基于master创建了一个用于维护的分支(Hotfix）。她在这个分支上修复了那个bug，然后把改动的代码<strong>直接合并入master</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b issue-#001 master</span><br><span class="line">\# Fix the bug</span><br><span class="line">git checkout master</span><br><span class="line">git merge issue-#001</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>​        跟用于发布的分支一样，在维护分支上的改动<strong>也需要合并入develop分支，这一点是很重要的！</strong>因此，张三务必不能忘了这一步。随后，她就<strong>可以将维护分支删除。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git merge issue-#001</span><br><span class="line">git push</span><br><span class="line">git branch -d issue-#001</span><br></pre></td></tr></table></figure><h1 id="四、Git-flow的问题"><a href="#四、Git-flow的问题" class="headerlink" title="四、Git flow的问题"></a>四、Git flow的问题</h1><blockquote><p> Git Flow 的问题：</p></blockquote><p>​         hotfix 和 release  分支引入的复杂性。这些分支对某些组织来说可能是一个好主意，但对绝大多数组织来说都是多余的。如今，大多数组织都在<strong>实践持续交付</strong>，这意味着可以部署您的默认分支。持续交付消除了对修补程序和发布分支的需求，包括它们引入的所有仪式。这个仪式的一个例子是发布分支的合并。尽管确实存在专门的工具来解决这个问题，但它们需要文档并增加了复杂性。开发人员经常会犯错误，例如仅将更改合并到主分支而不是开发分支。这些错误的原因是 Git 流程对于大多数用例来说太复杂了。例如，许多项目发布但不需要做修补程序。</p><hr><blockquote><p>对于Git Flow的问题，GitHub提供了一个更简单的替代方案：GitHub Flow</p></blockquote><pre><code>     [GitHub Flow](https://docs.github.com/en/get-started/quickstart/github-flow) 只有**功能分支(feature)和主分支(master)**：  这个流程简洁明了，许多组织都成功地采用了它。 Atlassian  推荐了一个类似的策略，尽管他们重新定义了特性分支。将所有内容合并到主分支并频繁部署意味着您可以最大限度地减少未发布代码的数量。这种方法符合精益和持续交付的最佳实践。然而，**这个流程仍然留下了很多关于部署、环境、发布和与问题集成的问题**。</code></pre><blockquote><p>对于GitHub Flow的问题，GitLab提供了GitLab Flow：见五</p></blockquote><h1 id="五、GitLab-Flow"><a href="#五、GitLab-Flow" class="headerlink" title="五、GitLab Flow"></a>五、GitLab Flow</h1><p>​        GitHub 工作流隐含一个假定：每次合并 feature，主分支的代码是立即发布的。然而，实际中常常不能满足这个假定，例如：你无法控制代码发布时间，例如 App 发布要等审核通过。再例如：发布时间窗口限制，合并分支的时候也许并不在发布时间窗口。</p><h2 id="1、GitLab-工作流中的生产分支（Production-branch"><a href="#1、GitLab-工作流中的生产分支（Production-branch" class="headerlink" title="1、GitLab 工作流中的生产分支（Production branch)"></a>1、GitLab 工作流中的生产分支（Production branch)</h2><p> GitLab 推荐用生产分支来解决上述GitHub Flow问题：</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/0bbbbb55b4905141924a341293b8d983.png" alt="image-20220224091518158"></p><p>​        Gitlab flow 的最大原则叫做**”上游优先”**（upsteam first），即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。</p><blockquote><p>对于”持续发布”的项目，它建议在master分支以外，再建立不同的环境分支。比如，</p></blockquote><ul><li>“开发环境”的分支是master。</li><li>“预发环境”的分支是pre-production。</li><li>“生产环境”的分支是production。</li></ul><p>​        开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，<strong>生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master</strong>，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。只有紧急情况，才允许跳过上游，直接合并到下游分支。</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/1f4a2b2e4de39c8b159cdf79c02007a8.png" alt="image-20220224091719794"></p><h2 id="2、版本发布"><a href="#2、版本发布" class="headerlink" title="2、版本发布"></a>2、版本发布</h2><p>​        对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支，比如2-3-stable、2-4-stable等等。</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/647e71f10aafc15bd00d5263c5772dc3.png" alt="image-20220224091906626"></p><h1 id="六、相关文档"><a href="#六、相关文档" class="headerlink" title="六、相关文档"></a>六、相关文档</h1><p><a href="https://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></p><p><a href="https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow">Gitflow Workflow</a> </p><p><a href="https://docs.github.com/en/get-started/quickstart/github-flow">GitHub Flow</a></p><p><a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">GitLab Flow</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是gitFlow工作流&quot;&gt;&lt;a href=&quot;#一、什么是gitFlow工作流&quot; class=&quot;headerlink&quot; title=&quot;一、什么是gitFlow工作流&quot;&gt;&lt;/a&gt;一、什么是gitFlow工作流&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Gitfl</summary>
      
    
    
    
    <category term="git" scheme="http://tosjw.cn/categories/git/"/>
    
    
    <category term="gitFlow" scheme="http://tosjw.cn/tags/gitFlow/"/>
    
  </entry>
  
  <entry>
    <title>Java Iterator(迭代器)</title>
    <link href="http://tosjw.cn/2022/02/16/Java-Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://tosjw.cn/2022/02/16/Java-Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2022-02-16T01:08:31.000Z</published>
    <updated>2022-06-18T03:09:39.602Z</updated>
    
    <content type="html"><![CDATA[<p>结构图:</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618110848929.png" alt="image-20220618110848929"></p><h1 id="1、简述java迭代器"><a href="#1、简述java迭代器" class="headerlink" title="1、简述java迭代器"></a>1、简述java迭代器</h1><p>​        Iterator迭代器的定义：迭代器（Iterator）模式，又叫做游标（Cursor）模式。GOF给出的定义是，提供一种方法访问一个容器container对象中各个元素，<strong>而又不需暴露该对象的内部细节</strong>。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><ul><li>它用于逐个遍历集合对象元素</li><li>它适用于所有Collection类，如上结构图所示</li><li>它支持read和<strong>remove</strong>操作</li></ul><blockquote><p>注意：对collection类遍历进行remove时不能使用for或者foreach，只能使用迭代器去操作，<a href="https://jingyan.baidu.com/article/d621e8da21e47e2865913fc8.html">否则抛同步异常</a></p></blockquote><h1 id="2、java-Iterator源码"><a href="#2、java-Iterator源码" class="headerlink" title="2、java Iterator源码"></a>2、java Iterator源码</h1><blockquote><p> 类图</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220222140613248.png" alt="img"></p><blockquote><p>方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查集合中是否还有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回迭代的下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchElementException 如果没有可迭代的元素将抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *将迭代器新返回的元素删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;remove&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对每个剩余元素执行给定操作，直到所有元素都被处理或操作抛出异常。</span></span><br><span class="line"><span class="comment">     * 如果指定了该顺序，则操作按迭代顺序执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">while</span> (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;item&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; listIterator = list.iterator();</span><br><span class="line">        <span class="comment">//判断是否还有元素</span></span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            System.err.println(listIterator.next());</span><br><span class="line">            <span class="comment">//对剩下的元素执行指定操作</span></span><br><span class="line">            listIterator.forEachRemaining((String consumer) -&gt; &#123;</span><br><span class="line">                System.err.println(consumer.concat(<span class="string">&quot;-test&quot;</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">item0</span><br><span class="line">item1-test</span><br><span class="line">item2-test</span><br><span class="line">item3-test</span><br><span class="line">item4-test</span><br></pre></td></tr></table></figure><h1 id="3、Iterator总结"><a href="#3、Iterator总结" class="headerlink" title="3、Iterator总结"></a>3、Iterator总结</h1><p>Java中的Iterator功能比较简单，并且只能<strong>单向移动</strong>：</p><p>(1) 方法iterator()将返回一个Iterator。首次调用next()方法时，它将返回第一个元素</p><p>(2) next() 返回下一个元素</p><p>(3) hasNext() 检查集合中是否还有元素</p><p>(4) remove() 将迭代器新返回的元素删除</p><p>(5) forEachRemaining() 对每个剩余的元素执行指定的操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;结构图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618110848929.png&quot; alt=&quot;image-20220618110848929&quot;&gt;&lt;/p</summary>
      
    
    
    
    <category term="java" scheme="http://tosjw.cn/categories/java/"/>
    
    
    <category term="迭代器" scheme="http://tosjw.cn/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java Streams操作</title>
    <link href="http://tosjw.cn/2022/02/14/java-Streams%E6%93%8D%E4%BD%9C/"/>
    <id>http://tosjw.cn/2022/02/14/java-Streams%E6%93%8D%E4%BD%9C/</id>
    <published>2022-02-14T09:12:53.000Z</published>
    <updated>2022-06-18T02:17:41.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Streams-流"><a href="#Streams-流" class="headerlink" title="Streams(流)"></a>Streams(流)</h2><p><code>java.util.Stream</code> 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如<code> java.util.Collection</code> 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码需要用到的数据List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;ddd2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;aaa2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb1&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;aaa1&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb3&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;bbb2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;ddd1&quot;</span>);</span><br></pre></td></tr></table></figure><p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面解释常用的Stream操作：</p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter(过滤)"></a>Filter(过滤)</h3><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于<strong>中间操作</strong>，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Filter(过滤)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">//aaa2 aaa1</span></span><br></pre></td></tr></table></figure><p>forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。</p><h3 id="Sorted-排序"><a href="#Sorted-排序" class="headerlink" title="Sorted(排序)"></a>Sorted(排序)</h3><p>排序是一个 <strong>中间操作</strong>，返回的是排序好后的 Stream。<strong>如果你不指定一个自定义的 Comparator 则会使用默认排序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Sort (排序)</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// aaa1 aaa2</span></span><br></pre></td></tr></table></figure><p>**自定义Comparator **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream()</span><br><span class="line">    .sorted(Comparator.comparing(Student::getAge)) <span class="comment">//正序</span></span><br><span class="line">list.stream()</span><br><span class="line">    .sorted(Comparator.comparing(Student::getAge).reversed()) <span class="comment">//逆序</span></span><br></pre></td></tr></table></figure><blockquote><p>补充：当然还可以不用借助steam方式直接排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.sort(Comparator.comparing(Integer::intValue)); <span class="comment">//正序</span></span><br><span class="line">list.sort(Comparator.comparing(Integer::intValue).reversed());<span class="comment">//逆序</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，排序只创建了一个排列好后的Stream，而<strong>不会影响原有的数据源</strong>，排序之后原数据stringList是不会被修改的：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringList);<span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map(映射)"></a>Map(映射)</h3><p>中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。</p><p>下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Map 操作</span></span><br><span class="line">stringList</span><br><span class="line">        .stream()</span><br><span class="line">        .map(String::toUpperCase)</span><br><span class="line">        .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">        .forEach(System.out::println);<span class="comment">// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;BBB1&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match(匹配)"></a>Match(匹配)</h3><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 <strong>最终操作</strong> ，并返回一个 boolean 类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 Match (匹配)操作</span></span><br><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">        stringList</span><br><span class="line">                .stream()</span><br><span class="line">                .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count(计数)"></a>Count(计数)</h3><p>计数是一个 <strong>最终操作</strong>，返回Stream中元素的个数，<strong>返回值类型是 long</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 Count (计数)操作</span></span><br><span class="line">  <span class="keyword">long</span> startsWithB =</span><br><span class="line">          stringList</span><br><span class="line">                  .stream()</span><br><span class="line">                  .filter((s) -&gt; s.startsWith(<span class="string">&quot;b&quot;</span>))</span><br><span class="line">                  .count();</span><br><span class="line">  System.out.println(startsWithB);    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce(规约)"></a>Reduce(规约)</h3><p>这是一个 <strong>最终操作</strong> ，允许通过指定的函数来将stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试 Reduce (规约)操作</span></span><br><span class="line">Optional&lt;String&gt; reduced = stringList.stream()</span><br><span class="line">             .sorted()</span><br><span class="line">                .reduce((s1, s2) -&gt; s1 + <span class="string">&quot;#&quot;</span> + s2);</span><br><span class="line">reduced.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>译者注：</strong> 这个方法的主要作用是把 Stream  元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n  个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于<code>Integer sum = integers.reduce(0, (a, b) -&gt; a+b);</code>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串连接，concat = &quot;ABCD&quot;</span></span><br><span class="line">String concat = Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>).reduce(<span class="string">&quot;&quot;</span>, String::concat); </span><br><span class="line"><span class="comment">// 求最小值，minValue = -3.0</span></span><br><span class="line"><span class="keyword">double</span> minValue = Stream.of(-<span class="number">1.5</span>, <span class="number">1.0</span>, -<span class="number">3.0</span>, -<span class="number">2.0</span>).reduce(Double.MAX_VALUE, Double::min); </span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 有起始值</span></span><br><span class="line"><span class="keyword">int</span> sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 求和，sumValue = 10, 无起始值</span></span><br><span class="line">sumValue = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>).reduce(Integer::sum).get();</span><br><span class="line"><span class="comment">// 过滤，字符串连接，concat = &quot;ace&quot;</span></span><br><span class="line">concat = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;F&quot;</span>).</span><br><span class="line"> filter(x -&gt; x.compareTo(<span class="string">&quot;Z&quot;</span>) &gt; <span class="number">0</span>).</span><br><span class="line"> reduce(<span class="string">&quot;&quot;</span>, String::concat);</span><br></pre></td></tr></table></figure><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为  BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的  reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： <a href="https://gitee.com/link?target=https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">IBM：Java 8 中的 Streams API 详解</a></p><h2 id="Parallel-Streams-并行流"><a href="#Parallel-Streams-并行流" class="headerlink" title="Parallel Streams(并行流)"></a>Parallel Streams(并行流)</h2><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。</p><h3 id="Sequential-Sort-串行排序"><a href="#Sequential-Sort-串行排序" class="headerlink" title="Sequential Sort(串行排序)"></a>Sequential Sort(串行排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;sequential sort took: %d ms&quot;</span>, millis));</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line">sequential sort took: <span class="number">709</span> ms<span class="comment">//串行排序所用的时间</span></span><br></pre></td></tr></table></figure><h3 id="Parallel-Sort-并行排序"><a href="#Parallel-Sort-并行排序" class="headerlink" title="Parallel Sort(并行排序)"></a>Parallel Sort(并行排序)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并行排序</span></span><br><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;parallel sort took: %d ms&quot;</span>, millis));</span><br><span class="line"><span class="number">1000000</span></span><br><span class="line">parallel sort took: <span class="number">475</span> ms<span class="comment">//串行排序所用的时间</span></span><br></pre></td></tr></table></figure><p>上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 <code>stream()</code> 改为<code>parallelStream()</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Streams-流&quot;&gt;&lt;a href=&quot;#Streams-流&quot; class=&quot;headerlink&quot; title=&quot;Streams(流)&quot;&gt;&lt;/a&gt;Streams(流)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.util.Stream&lt;/code&gt; 表示能应用在一组元素</summary>
      
    
    
    
    <category term="java" scheme="http://tosjw.cn/categories/java/"/>
    
    
    <category term="Streams流" scheme="http://tosjw.cn/tags/Streams%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>springboot分页</title>
    <link href="http://tosjw.cn/2021/12/31/springboot%E5%88%86%E9%A1%B5-1/"/>
    <id>http://tosjw.cn/2021/12/31/springboot%E5%88%86%E9%A1%B5-1/</id>
    <published>2021-12-30T17:51:35.000Z</published>
    <updated>2022-06-18T03:17:08.660Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="一、分页插件（pagehelper）"><a href="#一、分页插件（pagehelper）" class="headerlink" title="一、分页插件（pagehelper）"></a>一、分页插件（pagehelper）</h3><p>​        之前写项目时都是自己去写分页，头大！自己写的分页很可能要写两次查询，一次查内容，二次查条数。这种就是费力不讨好的事，所以去看了一下pagehelper分页插件（都说是最方便使用的分页插件），学完随便做个笔记。</p><p>​        <strong>pagehelper插件主要是把PageHelper.startPage(pageNum, pageSize)放在sql查询之前。他会去处理查询内容，进行分页处理。</strong></p><h5 id="1、导包"><a href="#1、导包" class="headerlink" title="1、导包"></a>1、导包</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pagehelper --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、分页请求类"><a href="#2、分页请求类" class="headerlink" title="2、分页请求类"></a>2、分页请求类</h5><p>​        <strong>用于接收请求信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageNum;</span><br><span class="line">    <span class="comment">//每页数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">    <span class="comment">//查询条件</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; params = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h5><ol><li><p>控制层</p><p>​        这里就是接收前端的json数据将其映射成pageRequest对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    QuestionService questionService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/selectQuestions&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;分页查询题库&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo&lt;Question&gt; <span class="title">selectQuestions</span><span class="params">(<span class="meta">@RequestBody</span> PageRequest pageRequest)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> questionService.selectQuestions(pageRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层</p><p>​        在service层中pagehelper插件会去实现分页效果。</p><p>​        <strong>主要语句：PageHelper.startPage(pageNum, pageSize)。它要放在查询sql的前面就对该查询结果有效。</strong></p><p>​        PageInfo：是该插件提供的一个返回类，可以封装查询的分页信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionServiceImpl</span> <span class="keyword">implements</span> <span class="title">QuestionService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    QuestionDao questionDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用分页插件完成分页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo&lt;Question&gt; <span class="title">selectQuestions</span><span class="params">(PageRequest pageRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pageNum = pageRequest.getPageNum();</span><br><span class="line">        <span class="keyword">int</span> pageSize = pageRequest.getPageSize();</span><br><span class="line">        PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">        List&lt;Question&gt; questionList = questionDao.selectQuestions(pageRequest.getParams());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PageInfo&lt;Question&gt;(questionList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dao层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuestionDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询试题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params：查询条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Question&gt; <span class="title">selectQuestions</span><span class="params">(<span class="meta">@Param(&quot;params&quot;)</span> Map&lt;String,Object&gt; params)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        mapper.xml中用<foreach>语句拼接查询条件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybati.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$&#123;&#125;不带&#x27;&#x27;,#&#123;&#125;自带引号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sjw.zxks.dao.QuestionDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectQuestions&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.sjw.zxks.pojo.Question&quot;</span>&gt;</span></span><br><span class="line">        select * from question</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;params != null&quot;</span>&gt;</span></span><br><span class="line">            where</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;params&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;and&quot;</span> <span class="attr">index</span>=<span class="string">&quot;key&quot;</span>  <span class="attr">item</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">                $&#123;key&#125; = $&#123;value&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="4、接口测试"><a href="#4、接口测试" class="headerlink" title="4、接口测试"></a>4、接口测试</h5><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20210126151605884.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h3 id=&quot;一、分页插件（pagehelper）&quot;&gt;&lt;a href=&quot;#一、分页插件（pagehelper）&quot; class=&quot;headerlink&quot; title=&quot;一、分页插件（pagehelper）&quot;&gt;&lt;/a&gt;一、分页插件（pagehelper）&lt;/h3&gt;&lt;p&gt;​</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://tosjw.cn/categories/SpringBoot/"/>
    
    
    <category term="springboot" scheme="http://tosjw.cn/tags/springboot/"/>
    
    <category term="分页" scheme="http://tosjw.cn/tags/%E5%88%86%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记</title>
    <link href="http://tosjw.cn/2021/12/31/docker%E7%AC%94%E8%AE%B0-1/"/>
    <id>http://tosjw.cn/2021/12/31/docker%E7%AC%94%E8%AE%B0-1/</id>
    <published>2021-12-30T17:46:49.000Z</published>
    <updated>2022-06-18T03:03:27.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Docker基本组成"><a href="#一、Docker基本组成" class="headerlink" title="一、Docker基本组成"></a>一、Docker基本组成</h1><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618104919441.png" alt="image-20220618104919441"></p><p><strong>镜像（image）：</strong></p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，通过这个镜像可以创建多个容器（最终项目运行就是在容器中）。</p><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>容器基本命令=》启动、停止、删除</p><p><strong>仓库（repository）：</strong></p><p>仓库就是存放镜像的地方</p><p>仓库分为共有仓库和私有仓库</p><p>Docker Hub（默认是国外的仓库）</p><p>阿里云镜像加速器（配置镜像加速=》常用！！）</p><h1 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h1><h2 id="1、安装步骤"><a href="#1、安装步骤" class="headerlink" title="1、安装步骤"></a>1、安装步骤</h2><p><a href="https://docs.docker.com/engine/install/centos/">docker官方安装指南(centos)</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、卸载旧的docker版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、设置镜像的仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo #默认的是国外的！！</span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #常用阿里云的镜像仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、安装docker相关组件（默认最新版）</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 6、启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> 7、检查是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618104956530.png" alt="image-20220618104956530"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 8、运行hello world</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105022708.png" alt="image-20220618105022708"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 9、查看docker镜像(mysql\redis是之前拉的镜像、按步骤现在只有hello-world的镜像)</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105038666.png" alt="image-20220618105038666"></p><h2 id="2、回顾hello-world流程"><a href="#2、回顾hello-world流程" class="headerlink" title="2、回顾hello-world流程"></a>2、回顾hello-world流程</h2><p>上面步骤中运行了hello-word镜像，执行docker run之后发生了什么？</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105102378.png" alt="image-20220618105102378"></p><h2 id="3、docker底层原理"><a href="#3、docker底层原理" class="headerlink" title="3、docker底层原理"></a>3、docker底层原理</h2><blockquote><p>docker是怎么工作的？</p></blockquote><p>docker是一个client-server结构的系统，docker的守护进程运行在主机上。通过socket从客服端访问！</p><p>dockerServer接收到Docker-Client的指令，就会执行这个命令！</p><p><img src="https://i.loli.net/2021/02/22/V1g3dE5uSD6bFWt.png" alt="image-20210219101422288"></p><blockquote><p>docker为什么比虚拟机快？</p></blockquote><p>1、docker有着比虚拟机更少的抽象层</p><p>2、docker利用的是宿主机的内核，vm需要的是guest OS</p><p><img src="https://i.loli.net/2021/02/24/NBrUb8WVMOeLYv5.png" alt="image-20210224182401352"></p><blockquote><p> 所有说，新建一个容器的时候，docker不需要像虚拟机一样加载一个操作系统内核，避免引导。虚拟机是加载guestOs，分钟级别的；而docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p></blockquote><p><img src="https://i.loli.net/2021/02/22/WutS1CdoXcg9kiK.png" alt="image-20210219102708472"></p><h1 id="三、阿里云镜像加速"><a href="#三、阿里云镜像加速" class="headerlink" title="三、阿里云镜像加速"></a>三、阿里云镜像加速</h1><p>登陆阿里云：控制台=》产品与服务=》容器镜像服务=》镜像加速器</p><p>选择对应的操作系统</p><p><img src="https://i.loli.net/2021/02/22/TQy23u7VlzwmLRE.png" alt="image-20210219095101195"></p><p><img src="https://i.loli.net/2021/02/22/lY81sNFLfdhAP3U.png" alt="image-20210219095150647"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置命令：这里是centos，版本要对应</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://hfvn90en.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="四、Docker常用命令"><a href="#四、Docker常用命令" class="headerlink" title="四、Docker常用命令"></a>四、Docker常用命令</h1><h2 id="1、帮助命令"><a href="#1、帮助命令" class="headerlink" title="1、帮助命令"></a>1、帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version #显示docker版本信息</span><br><span class="line">docker info #显示docker的系统信息、包括镜像和容器的数量</span><br><span class="line">docker 命令 --help #帮助命令</span><br></pre></td></tr></table></figure><p>帮助文档：<a href="https://docs.docker.com/reference/">官方文档</a></p><h2 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h2><h3 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h3><p>docker images</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">mysql         5.7       a70d36bc331a   4 weeks ago     449MB</span><br><span class="line">mysql         latest    c8562eaf9d81   4 weeks ago     546MB</span><br><span class="line">redis         latest    621ceef7494a   5 weeks ago     104MB</span><br><span class="line">hello-world   latest    bf756fb1ae65   13 months ago   13.3kB</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收</span></span><br><span class="line">REPOSITORY 镜像的仓库源</span><br><span class="line">TAG   镜像的标签</span><br><span class="line">IMAGE ID   镜像的id</span><br><span class="line">CREATED   镜像创建的时间</span><br><span class="line">SIZE       镜像的大小</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">命令可选项</span></span><br><span class="line">-a, --all           #列出所有镜像</span><br><span class="line">-q, --quiet         #只显示镜像的id</span><br></pre></td></tr></table></figure><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><p>docker search</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   10520     [OK]       </span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3928      [OK]       </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可选项，进行过滤搜索</span></span><br><span class="line">--filter=stars=3000 #搜索出来的镜像就是stars大于3000的</span><br><span class="line">[root@SJW-aliyun ~]# docker search mysql --filter=stars=4000</span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   10520     [OK]     </span><br></pre></td></tr></table></figure><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>docker pull</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]==》  eg: docker pull tomcat:8.5</span></span><br><span class="line">[root@SJW-aliyun ~]# docker pull tomcat</span><br><span class="line">Using default tag: latest #如果不写tag，默认就是latest</span><br><span class="line">latest: Pulling from library/tomcat</span><br><span class="line">b9a857cbf04d: Pull complete #分层下载，docker images的核心 联合文件系统</span><br><span class="line">d557ee20540b: Pull complete #如果下载该镜像的其它版本可以共用相同的层，不需要重复下载，极大地节省空间</span><br><span class="line">3b9ca4f00c2e: Pull complete </span><br><span class="line">667fd949ed93: Pull complete </span><br><span class="line">661d3b55f657: Pull complete </span><br><span class="line">511ef4338a0b: Pull complete </span><br><span class="line">a56db448fefe: Pull complete </span><br><span class="line">00612a99c7dc: Pull complete </span><br><span class="line">326f9601c512: Pull complete </span><br><span class="line">c547db74f1e1: Pull complete </span><br><span class="line">Digest: sha256:94cc18203335e400dbafcd0633f33c53663b1c1012a13bcad58cced9cd9d1305</span><br><span class="line">Status: Downloaded newer image for tomcat:latest</span><br><span class="line">docker.io/library/tomcat:latest</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p>docker rmi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker rmi a70d36bc331a #删除指定镜像[root@SJW-aliyun ~]# docker rmi 镜像id 镜像id #删除多个镜像[root@SJW-aliyun ~]# docker rmi $(docker images -aq) #删除多个镜像</span><br></pre></td></tr></table></figure><h2 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h2><blockquote><p>有了镜像才能 创建容器</p></blockquote><p>下载一个centos镜像来测试学习</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SJW-aliyun ~]# docker pull centosUsing default tag: latestlatest: Pulling from library/centos7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1Status: Downloaded newer image for centos:latestdocker.io/library/centos:latest</span><br></pre></td></tr></table></figure><h3 id="新建容器-并启动"><a href="#新建容器-并启动" class="headerlink" title="==新建容器==并启动"></a>==<strong>新建容器</strong>==并启动</h3><p>docker run</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image#可选参数说明--name=&quot;name&quot;容器别名，用来区分容器-d后台方式交互-it使用交互方式运行，加入容器查看内容-p指定容器端口 -p 主机端口:容器端口-P随机指定端口#测试，启动并进入容器[root@SJW-aliyun ~]# docker run -it centos /bin/bash[root@cd7a513e67b9 /]# ls#查看容器内的centos，其为基础版本，很多命令不完善bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var#从容器中退回主机[root@cd7a513e67b9 /]# exitexit</span><br></pre></td></tr></table></figure><h3 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h3><p>docker ps</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps 命令<span class="comment"># 列出当前正在运行的容器-a# 列出当前正在运行的容器+历史运行过的容器-n=？#显示最近创建的容器-q#只显示容器的编号[root@SJW-aliyun ~]# docker psCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES[root@SJW-aliyun ~]# docker ps -aCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                      PORTS     NAMEScd7a513e67b9   centos    &quot;/bin/bash&quot;              7 minutes ago   Exited (0) 5 minutes ago              hopeful_chaplygine27753e62511   redis     &quot;docker-entrypoint.s…&quot;   11 days ago     Exited (0) 59 minutes ago             redis</span></span></span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>docker rm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id#删除指定容器，不能删除正在运行的容器，如果要强制删除 rm -fdocker rm -f $(docker ps -a)#删除所有容器docker ps -a|xargs docker rm#删除所有容器</span><br></pre></td></tr></table></figure><h3 id="启动和停止容器操作"><a href="#启动和停止容器操作" class="headerlink" title="启动和停止容器操作"></a>启动和停止容器操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id#启动容器docker restart 容器id#重启容器docker stop 容器id#停止正在运行的容器docker kill 容器id#强制停止当前容器</span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit#直接容器停止并退出Ctrl + P + Q#容器不停止退出</span><br></pre></td></tr></table></figure><h3 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h3><p>后台启动容器（-d）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令 docker run -d 镜像名[root@SJW-aliyun ~]<span class="comment"># docker run -d centos#问题：运行docker ps，发现centos停止了#原因：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有运用就会自动停止。</span></span></span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -tf --tail 条数 容器id</span><br></pre></td></tr></table></figure><p>查看容器中的进程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top 容器id</span><br></pre></td></tr></table></figure><p>查看镜像元数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><p>进入当前正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器修改一些配置<span class="comment">#命令（方式一）docker exec -it 容器id bashShell#测试[root@SJW-aliyun ~]# docker psCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMESfe1741b3f823   centos    &quot;/bin/bash&quot;   17 seconds ago   Up 16 seconds             crazy_morse[root@SJW-aliyun ~]# docker exec -it fe1741b3f823 /bin/bash# 方式二docker attach 容器id#测试[root@SJW-aliyun ~]# docker psCONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMESfe1741b3f823   centos    &quot;/bin/bash&quot;   8 minutes ago   Up 8 minutes             crazy_morse[root@SJW-aliyun ~]# docker attach fe1741b3f823[root@fe1741b3f823 /]# # docker exec 进入容器开启一个新的终端，可以在里面操作（常用）# docker attach 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure><p>从容器内拷贝文件到主机上（宿主机）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令docker cp 容器id:容器内路径 宿主机路径<span class="comment">#测试[root@SJW-aliyun sjw]# docker attach fe1741b3f823进入docker容器[root@fe1741b3f823 /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@fe1741b3f823 /]# cd /home[root@fe1741b3f823 home]# touch test.java创建文件[root@fe1741b3f823 home]# lstest.java[root@fe1741b3f823 home]# exit退出容器exit[root@SJW-aliyun sjw]# docker cp fe1741b3f823:/home/test.java /home/sjw从容器内拷贝文件到主机上[root@SJW-aliyun sjw]# cd /home/sjw[root@SJW-aliyun sjw]# lstest.java[root@SJW-aliyun sjw]# # 拷贝是一个手动过程，未来可使用 -v 卷的技术。</span></span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://i.loli.net/2021/02/22/pnbmUDYPf4tvHjh.png" alt="image-20210222121826673"></p><h1 id="五、练习"><a href="#五、练习" class="headerlink" title="五、练习"></a>五、练习</h1><h2 id="1、部署nginx"><a href="#1、部署nginx" class="headerlink" title="1、部署nginx"></a>1、部署nginx</h2><blockquote><p>拉取nginx镜像，并启动。外部3344端口映射容器内部80端口，访问外部3344间接访问容器80端口。容器相对于小型linux系统</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105228787.png" alt="image-20220618105228787"></p><p>测试：访问3344端口</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105244252.png" alt="image-20220618105244252"></p><h2 id="2、部署tomcat"><a href="#2、部署tomcat" class="headerlink" title="2、部署tomcat"></a>2、部署tomcat</h2><blockquote><p>拉取tomcat镜像，并启动。</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105258238.png" alt="image-20220618105258238"></p><p>测试：访问tomcat</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105316053.png" alt="image-20220618105316053"></p><p>==ps：访问结果为404，那是因为tomcat镜像不是完整的默认是最小镜像，不必要的就被剔除掉，保证最小可运行环境！如下==</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105340793.png" alt="image-20220618105340793"></p><h1 id="六、Docker可视化"><a href="#六、Docker可视化" class="headerlink" title="六、Docker可视化"></a>六、Docker可视化</h1><p><strong>什么是portainer？</strong></p><p>Docker图形化管理工具，提供一个后台面板供我们使用！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock \--privileged=true portainer/portainer</span><br></pre></td></tr></table></figure><p>测试：外网访问8088，==记住要把阿里云安全组对应的端口号打开！！！==</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105355783.png" alt="image-20220618105355783"></p><p>创建一个用户、选择本地连接，下面就是可视化面板</p><p><img src="https://i.loli.net/2021/02/22/txj94mIAPnrifEX.png" alt="image-20210222160435296"></p><h1 id="六、commit镜像"><a href="#六、commit镜像" class="headerlink" title="六、commit镜像"></a>六、commit镜像</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本（镜像）相当于把原有的镜像经过自己的操作后封装成一个新的镜像# 此命令和git commit命令类似docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名[:TAG]</span><br></pre></td></tr></table></figure><p>==测试==</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、启动一个默认的tomcat<span class="comment"># 2、这个默认的tomcat是没有webapps运用（访问不了页面），镜像原因，官方的镜像默认webapps下面没有文件！# 3、将webapps.dist的文件拷贝进webapps里# 4、将操作过的容器通过commit提交为一个镜像！以后可直接使用修改过的镜像！！</span></span></span><br></pre></td></tr></table></figure><p>启动步骤省略，见上文！</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105451144.png" alt="image-20220618105451144"></p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105424249.png" alt="image-20220618105424249"></p><p>==如果想保存当前容器状态，就可以通过commit来提交，获得一个镜像==</p><h1 id="七、容器数据卷（重点）"><a href="#七、容器数据卷（重点）" class="headerlink" title="==七、容器数据卷（重点）=="></a>==七、容器数据卷（重点）==</h1><h2 id="1、什么是容器数据卷？"><a href="#1、什么是容器数据卷？" class="headerlink" title="1、什么是容器数据卷？"></a>1、什么是容器数据卷？</h2><blockquote><p>docker的理念回顾？</p></blockquote><p>将应用和环境打包成一个镜像！</p><blockquote><p>应用（容器）产生的数据该何去何从？</p></blockquote><p>如果数据都在容器中，那么删除容器的同时，数据也会丢失</p><p>==需要：数据可以持久化==</p><blockquote><p>什么是卷技术？</p></blockquote><p>容器之间可以有一个数据共享的技术！把docker容器中产生的数据同步到本地！</p><p>这就是卷技术！目录挂载，将我们容器的目录挂载到linux（宿主机）上面！！</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105506181.png" alt="image-20220618105506181"></p><p>==总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！（多个容器挂载到宿主机同一目录）==</p><h2 id="2、使用数据卷（通过命令）"><a href="#2、使用数据卷（通过命令）" class="headerlink" title="2、使用数据卷（通过命令）"></a>2、使用数据卷（通过命令）</h2><blockquote><p>方式一：直接使用命令来挂载 -v</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录# 测试[root@SJW-aliyun home]# docker run -it -v /home/test:/home centos /bin/bash</span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105521882.png" alt="image-20220618105521882"></p><p>使用 docker inspect命令查看容器详情</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105544259.png" alt="image-20220618105544259"></p><p><strong>测试文件的同步</strong></p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105554299.png" alt="image-20220618105554299"></p><h3 id="实战：安装mysql"><a href="#实战：安装mysql" class="headerlink" title="实战：安装mysql"></a>实战：安装mysql</h3><p>==目标：mysql数据持久化==</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、启动一个mysql容器，需要做数据挂载！需要配置mysql密码！<span class="comment"># 官方测试：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# -d后台运行 -p 端口映射 -e环境配置 -v卷挂载[root@SJW-aliyun /]# docker run -d -p 8082:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql</span></span></span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105610659.png" alt="image-20220618105610659"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2、在本地使用Navicat测试连接<span class="comment"># 本地连接阿里云服务器8082端口映射mysql容器3306端口进行访问！记得打开阿里云对应的端口组！</span></span></span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105648402.png" alt="image-20220618105648402"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 3、本地创建数据库<span class="comment"># 看文件是否挂载成功？</span></span></span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105714825.png" alt="image-20220618105714825"></p><blockquote><p>将mysql容器删除，数据还在不在？</p></blockquote><p>!<img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105732130.png" alt="image-20220618105732130"></p><p>==实践结果：mysql数据持久化成功！文件挂载成功！哈哈哈哈==</p><h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx<span class="comment"># 查看所有的volume（卷）的情况[root@SJW-aliyun _data]# docker volume lsDRIVER    VOLUME NAMElocal     3eaa24893e76eec6766865aa607f01c6f7e82268383f76b637165bbe93253c64#这种就是匿名挂载，我们在-v只写了容器内的路径没有写容器外的路径！！#具名挂载-v 卷名:容器内路径docker run -d -P --name nginx02 -v nginx02:/etc/nginx nginx[root@SJW-aliyun _data]# docker volume lsDRIVER    VOLUME NAMElocal     nginx02</span></span></span><br></pre></td></tr></table></figure><blockquote><p>查看卷的详情</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105744698.png" alt="image-20220618105744698"></p><p>所有的docker容器内的卷，没有指定目录的情况下(具名和匿名挂载)都是在==/var/lib/docker/volumes/xxx/_data==</p><p>通过具名挂载考研方便的找到我们的一个卷，大多数情况使用的是==具名挂载==</p><blockquote><p>如何确定是具名挂载、匿名挂载还是指定路径挂载！</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v 容器内路径#匿名挂载-v 卷名：容器内路径  #具名挂载-v 宿主机 路径：容器内路径#指定路径挂载</span><br></pre></td></tr></table></figure><blockquote><p>拓展：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 容器内路径：ro rw 改变读写权限ro：<span class="built_in">readonly</span> <span class="comment">#只读rw：readwrite #可读可写（默认）#一旦设置了容器权限，容器对我们挂载出来的内容就有了限定！docker run -d -P --name nginx01 -v /etc/nginx:ro nginxdocker run -d -P --name nginx01 -v /etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内无法操作！！</span></span></span><br></pre></td></tr></table></figure><h2 id="3、使用数据卷（通过DockerFile）"><a href="#3、使用数据卷（通过DockerFile）" class="headerlink" title="3、使用数据卷（通过DockerFile）"></a>3、使用数据卷（通过DockerFile）</h2><blockquote><p>方式二</p></blockquote><p>==DoockerFile就是用来构建docker镜像的文件！ 实质是命令脚本！==</p><p>通过脚本可以生成镜像，镜像是一层一层的，脚本是一个一个的命令，每个命令都是一层！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建一个dockerfile文件，文件随意<span class="comment">#文件中的内容：指令（大写）+参数FROM centosVOLUME [&quot;volume1&quot;,&quot;volume2&quot;]CMD echo &quot;---end---&quot;CMD /bin/bash#这里的每个命令都是镜像的一层！</span></span></span><br></pre></td></tr></table></figure><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105804723.png" alt="image-20220618105804723"></p><blockquote><p>启动自己创建的镜像</p></blockquote><p>不清楚为什么这里挂载成了一个目录（狗头），问题不大</p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105822654.png" alt="image-20220618105822654"></p><p><strong>这里的挂载肯定是个匿名挂载，只指定了容器内路径</strong></p><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105832960.png" alt="image-20220618105832960"></p><p>==这个卷和外部肯定有一个同步的目录==</p><blockquote><p>通过docker inspect命令查看容器详情，可查看挂载路径</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105846390.png" alt="image-20220618105846390"></p><p>==总结：==</p><p>​    ==使用dockerfile来挂载数据在未来使用得十分多，因为我们通常会构建自己的镜像，如果构建镜像时没有挂载卷，要手动镜像挂载 -v 容器外路径:容器内路径！！==</p><h2 id="4、数据卷容器"><a href="#4、数据卷容器" class="headerlink" title="4、数据卷容器"></a>4、数据卷容器</h2><blockquote><p>数据卷容器解决什么问题？</p></blockquote><p><strong>解决多个容器之间数据同步问题</strong></p><h1 id="八、DockerFile"><a href="#八、DockerFile" class="headerlink" title="八、DockerFile"></a>八、DockerFile</h1><h2 id="1、dockerfile介绍"><a href="#1、dockerfile介绍" class="headerlink" title="1、dockerfile介绍"></a>1、dockerfile介绍</h2><blockquote><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p></blockquote><p>==构建步骤：==</p><p>1、编写一个dockerfile文件</p><p>2、dockerfile build 构建成为一个镜像</p><p>3、docker run 运行镜像</p><p>4、docker push 发布镜像（DockerHub、阿里云镜像仓库）</p><blockquote><p>查看官方是怎么做的</p></blockquote><p><img src="https://sjw-storage.oss-cn-hangzhou.aliyuncs.com/img/image-20220618105933515.png" alt="image-20220618105933515"></p><p><strong>发现官方的镜像实质也是一个dockerfile</strong></p><p>==很多官方镜像都是基础包，很多功能没有，我们通常会搭建自己的镜像！==</p><h2 id="2、dockerfile构建过程"><a href="#2、dockerfile构建过程" class="headerlink" title="2、dockerfile构建过程"></a>2、dockerfile构建过程</h2><p><strong>基础知识：</strong></p><p>1、每个保留关键字（指令）都必须是大写字母</p><p>2、执行顺序从上到下</p><p>3、#表示注释</p><p>4、每个指令都会创建提交一个新的镜像层，并提交！</p><p><img src="https://i.loli.net/2021/02/25/jvCtOT2o9zi4YSw.png" alt="image-20210225125409723"></p><p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，文件十分简单！</p><p>docker镜像逐渐成为企业交付的标准，必须要掌握！</p><h2 id="3、dockerfile指令"><a href="#3、dockerfile指令" class="headerlink" title="3、dockerfile指令"></a>3、dockerfile指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM#基础镜像，一切从这里开始构建MAINTAINER#镜像是谁写的，姓名+邮箱RUN#镜像构建时需要运行的命令ADD#添加内容WORKDIR#镜像的工作目录VOLUME#挂载的目录EXPOSE#保留端口配置CMD#指定容器启动时运行的命令，只有最后一个会生效，可被代替ENTRYPOINT#指定容器启动时运行的命令，可追加命令ONBUILD#当构建一个被继承Dockerfile，这个时候就会运行ONBUILD指令。触发指令COPY#类似ADD，将我们文件拷贝到镜像中ENY#构建时设置环境变量，例如mysql密码</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/25/Exuyz3dJqCieZTM.png" alt="image-20210225133308729"></p><h2 id="4、实战测试"><a href="#4、实战测试" class="headerlink" title="4、实战测试"></a>4、实战测试</h2><blockquote><p>官方的centos是简化版，很多东西不全，比如vim命令</p></blockquote><p><img src="https://i.loli.net/2021/02/25/Bdx4lpEUajOIRHX.png" alt="image-20210225163829635"></p><blockquote><p>通过dockerfile创建自己的镜像，在官方原有镜像的基础上添加vim</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、编写dockerfile文件[root@SJW-aliyun dockerfile]<span class="comment"># vim mydockerfile-centos[root@SJW-aliyun dockerfile]# cat mydockerfile-centos FROM centosMAINTAINER sjw&lt;2855289411&gt;EVN MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimEXPOSE 80CMD echo $MYPATHCMD &quot;----end----&quot;CMD /bin/bash# 2、通过文件构建镜像# 命令：docker build -f dockerfile文件路径 -t 镜像名[:TAG] .# 3、测试运行</span></span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/25/ADvWkhHRmMbVdXo.png" alt="image-20210225165707240"></p><p><img src="https://i.loli.net/2021/02/25/dwAIgJ8pTshD2ay.png" alt="image-20210225165908727"></p><p>==测试成功！！！==</p><blockquote><p>我们可以列出本地镜像的变更历史（docker history 镜像id）</p></blockquote><p><img src="https://i.loli.net/2021/02/25/pcO4FJnrQhmxkqV.png" alt="image-20210225170227228"></p><h2 id="5、实战：Tomcat镜像"><a href="#5、实战：Tomcat镜像" class="headerlink" title="5、实战：Tomcat镜像"></a>5、实战：Tomcat镜像</h2><h1 id="八、发布镜像"><a href="#八、发布镜像" class="headerlink" title="八、发布镜像"></a>八、发布镜像</h1><h2 id="1、发布到DockerHub"><a href="#1、发布到DockerHub" class="headerlink" title="1、发布到DockerHub"></a>1、发布到DockerHub</h2><p>==步骤：==</p><p>1、在dockerhub官网注册自己的帐号！</p><p>2、确定账户可以登陆</p><p>3、在自己的阿里云上登陆docker</p><blockquote><p>命令：docker login</p></blockquote><p><img src="https://gitee.com/coder-SJW/blogimg/raw/master/img/6F54XuHbN8aUG1D.png" alt="image-20210226104132151"></p><p>4、登陆成功后就可以发布镜像</p><blockquote><p>命令：docker push</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Docker基本组成&quot;&gt;&lt;a href=&quot;#一、Docker基本组成&quot; class=&quot;headerlink&quot; title=&quot;一、Docker基本组成&quot;&gt;&lt;/a&gt;一、Docker基本组成&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://sjw-storage.</summary>
      
    
    
    
    <category term="Docker" scheme="http://tosjw.cn/categories/Docker/"/>
    
    
    <category term="docker" scheme="http://tosjw.cn/tags/docker/"/>
    
  </entry>
  
</feed>
